<library>


    <!-- Application View -->
    <!-- Written for Micropolis -->
    <!-- By Don Hopkins -->
    <!-- Licensed under GPLv3 -->


    <class name="appview">


        <attribute name="active" value="true"/>
        <attribute name="pollDelay" value="250"/>
        <attribute name="pollDelaySoon" value="10"/>
        <attribute name="animateDelay" value="250"/>
<!--
        <attribute name="pollDelay" value="100"/>
        <attribute name="animateDelay" value="100"/>
-->
        <attribute name="pollActive" value="false"/>
        <attribute name="pollDelegate" value="null"/>
        <attribute name="polls" value="1"/>
        <attribute name="pollers" value="[]"/>
        <attribute name="idles" value="1"/>
        <attribute name="idlers" value="[]"/>
        <attribute name="animateActive" value="false"/>
        <attribute name="animateDelegate" value="null"/>
        <attribute name="animationTicks" value="1"/>
        <attribute name="animatorsList" value="[]"/>
        <attribute name="commandQueue" value="[]"/>
        <attribute name="worldCols" value="120"/>
        <attribute name="worldRows" value="100"/>
        <attribute name="tileDictRows" value="null"/>
        <attribute name="codeString" type="string" value="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-"/>
        <attribute name="codeMap" value="null"/>
        <attribute name="newTilesMax" value="300"/>
        <attribute name="newTiles" value="0"/>
        <attribute name="quaking" value="0"/>
        <attribute name="connected" value="false"/>
        <attribute name="connecting" value="false"/>
        <attribute name="connectionFailed" value="false"/>
        <attribute name="title" type="string" value=""/>
        <attribute name="description" type="string" value=""/>
        <attribute name="paused" value="true"/>
        <attribute name="speed" type="number" value="3"/>
        <attribute name="funds" type="number" value="0"/>
        <attribute name="year" type="number" value="1900"/>
        <attribute name="month" type="number" value="0"/>
        <attribute name="dateLabel" type="string" value=""/>
        <attribute name="demand" value="null"/>
        <attribute name="evaluation" value="null"/>
        <attribute name="history" value="null"/>
        <attribute name="taxRate" type="number" value="7"/>
        <attribute name="roadPercent" type="number" value="100"/>
        <attribute name="roadFund" type="number" value="0"/>
        <attribute name="roadValue" type="number" value="0"/>
        <attribute name="firePercent" type="number" value="100"/>
        <attribute name="fireFund" type="number" value="0"/>
        <attribute name="fireValue" type="number" value="0"/>
        <attribute name="policePercent" type="number" value="100"/>
        <attribute name="policeFund" type="number" value="0"/>
        <attribute name="policeValue" type="number" value="0"/>
        <attribute name="gameMode" type="string" value="disconnected"/>
        <attribute name="gap" value="5"/>
        <attribute name="nextUniqueID" value="1"/>
        <attribute name="interests" value="$once{{}}"/>
        <attribute name="overlay" type="string" value="all"/>
        <attribute name="aboutURL" type="string" value="http://www.MicropolisOnline.com/wiki/index.php/About"/>
        <attribute name="helpURL" type="string" value="http://www.MicropolisOnline.com/wiki/index.php/Help"/>
        <attribute name="monthNames" value="$once{[
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ]}"/>


        <handler name="oninit"><![CDATA[
            var codeString = this.codeString;
            var codeMap = {};
            this.codeMap = codeMap;

            this.expressInterest(this, [
                'speed', 'paused', 'taxrate', 'date', 'funds', 
                'demand', 'evaluation', 'history'
            ]);

            var i;
            for (i = 0; i < codeString.length; i++) {
                var c = codeString.substr(i, 1);
                codeMap[c] = i;
            }

            var tileDictRows = [];
            this.tileDictRows = tileDictRows;
            var row;
            for (row = 0; row < this.worldRows; row++) {
                var tileDictRow = new Array(this.worldCols);
                tileDictRows.push(tileDictRow);
            }

            this.requestStartSession();

            // Note: We must initialize interests above in the attribute once clause.
            // Because if we initialize it here, we are running after the children's
            // oninit's have been run, so we would wipe out their interests. 

          ]]>
        </handler>


        <handler name="ongameMode" args="arg"><![CDATA[
            switch (this.gameMode) {
                case 'disconnected': {
                    break;
                }
                case 'start': {
                    this.setAttribute(
                        "title",
                        "Micropolis: Choose a City");
                    this.setAttribute(
                        "description",
                        "Welcome to Micropolis!<br/><br/>\n" +
                        "Choose a city by selecting a scenario from " +
                        "the 'Scenarios' tab, or generating a new " +
                        "random city from the 'Generator' tab, or " +
                        "loading a city in the library from the " +
                        "'Library' tab.<br/><br/>\n" +
                        "Then press the 'Play with This City' button " +
                        "below, to start playing Micropolis!");
                    break;
                }
                case 'play': {
                    break;
                }
            }
          ]]>
        </handler>


        <handler name="onpaused" args="arg"><![CDATA[
            var cmd =
                '<command name="setPaused" paused="' +
                (this.paused ? 'true' : 'false') +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="onspeed" args="arg"><![CDATA[
            var cmd =
                '<command name="setSpeed" speed="' +
                this.speed +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="ontaxRate" args="arg"><![CDATA[
            var cmd =
                '<command name="setTaxRate" taxRate="' +
                this.taxRate +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="onroadPercent"><![CDATA[
            var cmd =
                '<command name="setRoadPercent" roadPercent="' + 
                this.roadPercent +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="onfirePercent"><![CDATA[
            var cmd =
                '<command name="setFirePercent" firePercent="' + 
                this.firePercent +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="onpolicePercent"><![CDATA[
            var cmd =
                '<command name="setPolicePercent" policePercent="' + 
                this.policePercent +
                '"/>';
            this.sendCommand(cmd);
          ]]>
        </handler>


        <handler name="onconnected" args="arg"><![CDATA[
            if (!this.connected) {
                this.setAttribute("gameMode", "disconnected");
            }
          ]]>
        </handler>


        <handler name="onoverlay" args="arg"><![CDATA[
            this.updateMap();
          ]]>
        </handler>


        <method name="expressInterest" args="target, names"><![CDATA[
            var interests = this.interests;
            var n = names.length;
            var i;
            for (i = 0; i < n; i++) {
                var name = names[i];
                if (!(name in interests)) {
                    interests[name] = [target];
                } else {
                    var a = interests[name];
                    var j = this.indexOf(a, target);
                    if (j < 0) {
                        a.push(target);
                    }
                }
            }
          ]]>
        </method>


        <method name="revokeInterest" args="target, names"><![CDATA[
            var interests = this.interests;
            var name;
            var n = names.length;
            var i;
            for (i = 0; i < n; i++) {
                var name = names[i];
                if (!(name in interests)) {
                    continue;
                }
                var a = interests[name]
                var j = this.indexOf(a, target);
                if (j >= 0) {
                    a.splice(j, 1);
                }
            }
          ]]>
        </method>


        <method name="handleUpdate" args="args"><![CDATA[

            //Debug.write("appview handleUpdate", this, args);

            var aspect = args['aspect'];

            switch (aspect) {

                case 'speed': {
                    var paused = parseInt(args['speed']);
                    if (this.speed != speed) {
                        this.setAttribute("speed", speed);
                    }
                    break;
                }

                case 'paused': {
                    var paused = args['paused'] == "true";
                    if (this.paused != paused) {
                        this.setAttribute("paused", paused);
                    }
                    break;
                }

                case 'taxrate': {
                    var taxRate = parseInt(args['taxRate']);
                    if (taxRate != this.taxRate) {
                        this.setAttribute("taxRate", taxRate);
                    }
                    break;
                }

                case 'date': {
                    var year = args['year'];
                    var month = args['month'];
                    var dateLabel = this.formatMonthYear(month, year);
                    if (this.year != year) {
                        this.setAttribute("year", year);
                    }
                    if (this.month != month) {
                        this.setAttribute("month", month);
                    }
                    if (this.dateLabel != dateLabel) {
                        this.setAttribute("dateLabel", dateLabel);
                    }
                    break;
                }

                case 'demand': {
                    var demand = [
                        args['resDemand'],
                        args['comDemand'],
                        args['indDemand']
                    ];
                    this.setAttribute("demand", demand);
                    break;
                }

                case 'evaluation': {
                    var evaluation = args['evaluation'];
                    this.setAttribute('evaluation', evaluation);
                    break;
                }

                case 'history': {
                    var history = args['history'];
                    this.setAttribute('history', history);
                    break;
                }

                case 'funds': {
                    var funds = args['funds'];
                    var fundsLabel = this.formatFunds(funds);
                    this.setAttribute("funds", funds);
                    this.setAttribute("fundsLabel", fundsLabel);
                    break;
                }

                case 'taxrate': {
                    var taxRate = parseInt(args['taxRate']);
                    if (taxRate != this.taxRate) {
                        this.setAttribute("taxRate", taxRate);
                    }
                    break;
                }

                case 'budget': {
                    var names = [
                        "taxRate",
                        "roadPercent",
                        "roadFund",
                        "roadValue",
                        "firePercent",
                        "fireFund",
                        "fireValue",
                        "policePercent",
                        "policeFund",
                        "policeValue"
                    ];
                    var n = names.length;
                    var i;
                    for (i = 0; i < n; i++) {
                        var name = names[i];
                        var val = parseInt(args[name]);
                        if (this[name] != val) {
                            this.setAttribute(name, val);
                        }
                    }
                    break;
                }

            }

          ]]>
        </method>
        

        <method name="indexOf" args="a, obj"><![CDATA[
            var i;
            var n = a.length;
            for (i = 0; i < n; i++) {
                if (a[i] == obj) {
                    return i;
                }
            }
            return -1;
          ]]>
        </method>


        <method name="makeUniqueID"><![CDATA[
            var uniqueID = this.nextUniqueID;
            this.nextUniqueID++;
            return uniqueID;
          ]]>
        </method>


        <method name="requestStartSession"><![CDATA[
            this.setAttribute("gameMode", "disconnected");
            this.setAttribute("connected", false);
            this.setAttribute("connecting", true);
            this.setAttribute("connectionFailed", false);

            ds_session.setAttribute("src", "/server/micropolisSessionStart");
            ds_session.doRequest();
          ]]>
        </method>


        <method name="startSession" args="sessionID"><![CDATA[
            this.setAttribute("gameMode", "start");
            this.setAttribute("connected", true);
            this.setAttribute("connecting", false);
            this.setAttribute("connectionFailed", false);
            this.setAttribute("sessionID", sessionID);
            this.pollStart();
            this.animateStart();

            this.updateMap();
          ]]>
        </method>


        <method name="failSession"><![CDATA[
            this.setAttribute("gameMode", "disconnected");
            this.setAttribute("connected", false);
            this.setAttribute("connecting", false);
            this.setAttribute("connectionFailed", true);
            this.setAttribute("sessionID", null);
            this.pollStop();
            this.animateStop();
          ]]>
        </method>


        <method name="failPoll"><![CDATA[
            this.failSession();
          ]]>
        </method>


        <method name="addIdler" args="idler"><![CDATA[
            //Debug.write("appview addIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i < 0) {
                this.idlers.push(idler);
            }
          ]]>
        </method>


        <method name="removeIdler" args="idler"><![CDATA[
            //Debug.write("appview removeIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i >= 0) {
                this.idlers.splice(i, 1);
            }
          ]]>
        </method>


<!--
        <handler name="onidle" reference="lz.IdleService.LzIdle"><![CDATA[

            this.idles++;

            var idlers = this.idlers;
            var n = idlers.length;
            var i;

            for (i = 0; i < n; i++) {
                idlers[i].idle();
            }

          ]]>
        </handler>
-->


        <method name="addAnimator" args="animator"><![CDATA[
            //Debug.write("appview addAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i < 0) {
                this.animatorsList.push(animator);
            }

            if (!this.animateActive) {
                this.animateStart();
            }
          ]]>
        </method>


        <method name="removeAnimator" args="animator"><![CDATA[
            //Debug.write("appview removeAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i >= 0) {
                this.animatorsList.splice(i, 1);
            }

            if (this.animateActive &&
                this.animatorsList.length == 0) {
                this.animateStop();
            }
          ]]>
        </method>


        <method name="animateStart"><![CDATA[
            //Debug.write("animateStart");
            if (this.animateActive) {
                //Debug.write("animateStart already started");
                return;
            }
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            var t = lz.Timer.addTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
          ]]>
        </method>


        <method name="animateContinue"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor animateStart and animateContinue.
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            lz.Timer.resetTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
            //Debug.write("animateContinue");
          ]]>
        </method>


        <method name="animateStop"><![CDATA[
            //Debug.write("animateStop");
            if (!this.animateActive) {
                return;
            }
            lz.Timer.removeTimer(this.animateDelegate);
            this.animateActive = false;
          ]]>
        </method>


        <method name="doAnimate" args="ignore"><![CDATA[

            //Debug.write("doAnimate");

            this.animationTicks++;
            this.newTiles = 0;

            var animatorsList = this.animatorsList;
            var n = animatorsList.length;
            var i;
            for (i = 0; i < n; i++) {
                animatorsList[i].doAnimate();
            }

            this.animateContinue();

          ]]>
        </method>


        <method name="addPoller" args="poller"><![CDATA[
            //Debug.write("appview addPoller", poller, this.pollers.length);
            var i = this.indexOf(this.pollers, poller);
            if (i < 0) {
                this.pollers.push(poller);
            }
          ]]>
        </method>


        <method name="removePoller" args="poller"><![CDATA[
            //Debug.write("appview removePoller", poller, this.pollers.length);
            var i = this.indexOf(this.pollers, poller);
            if (i >= 0) {
                this.pollers.splice(i, 1);
            }
          ]]>
        </method>


        <method name="pollStart"><![CDATA[
            //Debug.write("pollStart");
            if (this.pollActive) {
                //Debug.write("pollStart already started");
                return;
            }
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            var t = lz.Timer.addTimer(this.pollDelegate, this.pollDelay);
            this.pollActive = true;
          ]]>
        </method>


        <method name="pollContinue" args="soon"><![CDATA[
            //Debug.write("pollContinue", soon);
            // This is a bit confused, and violates DRY. Refactor pollStart and pollContinue.
            //this.pollStop();
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            lz.Timer.resetTimer(this.pollDelegate, soon ? this.pollDelaySoon : this.pollDelay);
            this.pollActive = true;
            //Debug.write("pollContinue");
          ]]>
        </method>


        <method name="pollStop"><![CDATA[
            //Debug.write("pollStop");
            if (!this.pollActive) {
                return;
            }
            lz.Timer.removeTimer(this.pollDelegate);
            this.pollActive = false;
          ]]>
        </method>


        <method name="poll" args="ignore"><![CDATA[
            //Debug.write("POLL!");
            var i, n;
            var body = [];

            var ref = this.polls;
            this.polls++;

            body.push("<poll ref=\"" + ref + "\" sessionID=\"" + this.sessionID + "\">");

            var pollers = this.pollers;
            n = pollers.length;
            if (n > 0) {
                body.push("<pollers>")
                for (i = 0; i < n; i++) {
                    body.push(pollers[i].poll());
                }
                body.push("</pollers>");
            }

            var commandQueue = this.commandQueue;
            if (commandQueue && commandQueue.length > 0) {
                this.commandQueue = [];
                body.push("<commands>");
                n = commandQueue.length;
                for (i = 0; i < n; i++) {
                    var command = commandQueue[i];
                    body.push(command);
                }
                body.push("</commands>");
            }

            body.push("</poll>");

            body = body.join("");

            //Debug.write(body);

            var params = {
                ref: ref,
                sessionID: this.sessionID,
                rand: Math.random(),
                body: body
            };

            this.pollStop();

            ds_poll.setAttribute("src", "/server/micropolisPoll");
            ds_poll.setQueryParams(params);
            ds_poll.setAttribute("querytype", "post");
            ds_poll.doRequest();
            //Debug.write("SEND POLL");

          ]]>
        </method>


        <method name="sendCommand" args="command"><![CDATA[
            if (typeof(command) != "string") {
                command = command.serialize();
            }
            Debug.write("==== sendCommand", command);
            this.commandQueue.push(command);
            this.pollContinue(true);
          ]]>
        </method>


        <method name="updateMap"><![CDATA[
            this.handle_UIUpdate({
                aspect:'map'
            });
          ]]>
        </method>


        <method name="updateTiles" args="col, row, cols, rows, format, codedTiles"><![CDATA[
            //Debug.write("row", row, "col", col, "rows", rows, "cols", cols, "format", format);
            //Debug.write("codedTiles.length", codedTiles.length, codedTiles.substr(0, 20));

            var tileDictRows = this.tileDictRows;
            var codeMap = this.codeMap;
            var aniTiles = gAniTiles;

            switch (format) {

                case 0: {
                    var lastCol = col + cols;
                    var lastRow = row + rows;
                    var r, c;
                    var codeOffset = 0;
                    for (r = row; r < lastRow; r++) {
                        var tileDictRow = tileDictRows[r];
                        for (c = col; c < lastCol; c++) {
                            var c1 = 
                                codedTiles.substr(codeOffset, 1);
                            var c2 =
                                codedTiles.substr(codeOffset + 1, 1);
                            var tileIndex = 
                                (((codeMap[c2] * 64) + codeMap[c1]) & 1023);

                            var tileDict = tileDictRow[c];
                            if (!tileDict) {
                                tileDict = {
                                    'animationTicks': -1
                                };
                                tileDictRow[c] = tileDict;
                            }

                            tileDict['index'] = tileIndex;
                            tileDict['animated'] = aniTiles[tileIndex] != tileIndex;

                            codeOffset += 2;
                        }
                    }
                    break;
                }

                case 1: {
                    var tileOffset = 0;
                    var tileOffsetMax = rows * cols;
                    var codeOffset = 0;
                    var codeOffsetMax = codedTiles.length;

                    function getNumber1()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset += 1;
                        return codeMap[c1];
                    }

                    function getNumber2()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        codeOffset += 2;
                        return codeMap[c1] + (codeMap[c2] * 64);
                    }

                    function getNumber3()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        var c3 = codedTiles.substr(codeOffset + 2, 1);
                        codeOffset += 3;
                        return codeMap[c1] + (codeMap[c2] * 64) + (codeMap[c2] * 4096);
                    }

                    var charHandlers = {
                        '.': function() { tileOffset += 1; },
                        ':': function() { tileOffset += 2; },
                        ',': function() { tileOffset += 3; },
                        ';': function() { tileOffset += 4; },
                        '!': function() { tileOffset += getNumber1() + 2; },
                        '@': function() { tileOffset += getNumber2() + 2; },
                        '#': function() { tileOffset += getNumber3() + 2; }
                    };

                    while ((tileOffset >= 0) && 
                           (tileOffset < tileOffsetMax) &&
                           (codeOffset < codeOffsetMax)) {

                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset++;

                        var charHandler = charHandlers[c1];
                        if (charHandler) {
                            charHandler();
                            continue;
                        }

                        var c2 = codedTiles.substr(codeOffset, 1);
                        codeOffset++

                        var tileIndex = 
                            (codeMap[c1] + (codeMap[c2] * 64));

                        var c = tileOffset % cols;
                        var r = Math.floor(tileOffset / cols);

                        var tileDictRow = tileDictRows[row + r];
                        var tileDict = tileDictRow[col + c];
                        
                        if (!tileDict) {
                            tileDict = {
                                'animationTicks': -1
                            };
                            tileDictRow[col + c] = tileDict;
                        }

                        tileDict['index'] = tileIndex;
                        tileDict['animated'] = aniTiles[tileIndex] != tileIndex;

                        tileOffset++;

                    }
                    break;
                }

            }
          ]]>
        </method>


        <method name="getTileDict" args="col, row"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            var tileDict = tileDictRow[col];
            return tileDict;
          ]]>
        </method>


        <method name="setTileDict" args="col, row, tileDict"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            tileDictRow[col] = tileDict;
          ]]>
        </method>


        <method name="resetCity"><![CDATA[

            // TODO: Reset stuff for a new city.

            this.setAttribute("quaking", 0);
            this.updateMap();

          ]]>
        </method>


        <method name="abandonCity"><![CDATA[
            //Debug.write("abandonCity");
            this.sendCommand('<command name="abandonCity"/>');
          ]]>
        </method>


        <method name="saveCity"><![CDATA[
            //Debug.write("saveCity");
            this.sendCommand('<command name="saveCity"/>');
          ]]>
        </method>


        <method name="help"><![CDATA[
            lz.Browser.loadURL(
                this.helpURL,
                '_blank');
          ]]>
        </method>


        <method name="about"><![CDATA[
            lz.Browser.loadURL(
                this.aboutURL,
                '_blank');
          ]]>
        </method>


        <method name="handle_UIUpdate" args="args"><![CDATA[
            var aspect = args['aspect'];
            var interests = this.interests;
            //Debug.write("==== UIUpdate", aspect, args);
            
            if (!(aspect in interests)) {
               return;
            }

            var a = interests[aspect];
            //Debug.write("UPDATE ASPECT", aspect, a, args);
            var n = a.length;
            var i;
            for (i = 0; i < n; i++) {
                var target = a[i];
                target.handleUpdate(args);
            }
          ]]>
        </method>


        <method name="handle_UIDidGenerateNewCity" args="args"><![CDATA[
            //Debug.write("UIDidGenerateNewCity");
            this.resetCity();
          ]]>
        </method>


        <method name="handle_UIDidLoadCity" args="args"><![CDATA[
            //Debug.write("UIDidLoadCity");
            this.resetCity();
          ]]>
        </method>


        <method name="handle_UIDidLoadScenario" args="args"><![CDATA[
            //Debug.write("UIDidLoadScenario");
            this.resetCity();
            var scenario = args['scenario'];
            var number = 49 + scenario;
            gNoticeView.setCurrentNotice(number, null, null);
          ]]>
        </method>


        <method name="handle_UIStartEarthquake" args="args"><![CDATA[
            this.setAttribute("quaking", parseInt(args['magnitude']));
          ]]>
        </method>


        <method name="handle_UIStopEarthquake" args="args"><![CDATA[
            this.setAttribute("quaking", 0);
          ]]>
        </method>


        <method name="handle_UIShowBudgetAndWait" args="args"><![CDATA[
            //Debug.write("Show budget and wait...");
          ]]>
        </method>


        <method name="handle_UIMakeSound" args="args"><![CDATA[
            var channel = args['channel'];
            var sound = args['sound'];
            //Debug.write("MAKE SOUND", "channel", channel, "sound", sound);
          ]]>
        </method>


        <method name="handle_UINewGame" args="args"><![CDATA[
            //Debug.write("UINewGame");
          ]]>
        </method>


        <method name="playWithThisCity"><![CDATA[
            this.setAttribute("gameMode", "play");
            this.sendCommand('<command name="setGameMode" gameMode="play"/>');
          ]]>
        </method>


        <method name="chooseCity"><![CDATA[
            this.setAttribute("gameMode", "start");
            this.sendCommand('<command name="setGameMode" gameMode="start"/>');
          ]]>
        </method>


        <method name="formatFunds" args="funds"><![CDATA[
            return this.formatNumber(funds, '$');
          ]]>
        </method>


        <method name="formatNumber" args="n, dollar"><![CDATA[
            var minus = (n < 0);
            if (minus) {
                n = -n;
            }

            var digits = "" + n;

            var a = [];
            while (digits.length > 0) {
                a.unshift(digits.substr(-3, 3));
                digits = digits.substr(0, digits.length - 3);
            }

            var nStr = 
                (minus ? "-" : "") +
                (dollar ? dollar : '') +
                a.join(',');

            return nStr;
          ]]>
        </method>


        <method name="formatMonthYear" args="month, year"><![CDATA[
            var monthName = this.monthNames[month];
            var monthYear = monthName + " " + year;
            return monthYear;
          ]]>
        </method>


        <sessionhandler id="gSessionHandler"/>

        <pollhandler id="gPollHandler"/>


        <connectscreen id="gConnectScreen" name="connectScreen"
            x="5"
            y="5"
            width="${parent.width - 10}"
            height="${parent.height - 10}"
            visible="${classroot.gameMode == 'disconnected'}"
            active="${classroot.active &amp;&amp; this.visible}"
        />

        <startscreen id="gStartScreen" name="startScreen"
            x="5"
            y="5"
            width="${parent.width - 10}"
            height="${parent.height - 10}"
            visible="${classroot.gameMode == 'start'}"
            active="${classroot.active &amp;&amp; this.visible}"
        />

        <playscreen id="gPlayScreen" name="playScreen"
            x="0"
            y="0"
            width="${parent.width}"
            height="${parent.height}"
            visible="${classroot.gameMode == 'play'}"
            active="${classroot.active &amp;&amp; this.visible}"
        />


    </class>


</library>
