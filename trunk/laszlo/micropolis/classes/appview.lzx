<library>


    <!-- Application View -->
    <!-- Written for Micropolis -->
    <!-- By Don Hopkins -->
    <!-- Licensed under GPLv3 -->


    <class name="appview">


        <attribute name="pollDelay" value="250"/>
        <attribute name="animateDelay" value="250"/>
<!--
        <attribute name="pollDelay" value="100"/>
        <attribute name="animateDelay" value="100"/>
-->
        <attribute name="pollActive" value="false"/>
        <attribute name="pollDelegate" value="null"/>
        <attribute name="polls" value="1"/>
        <attribute name="pollers" value="[]"/>
        <attribute name="idles" value="1"/>
        <attribute name="idlers" value="[]"/>
        <attribute name="animateActive" value="false"/>
        <attribute name="animateDelegate" value="null"/>
        <attribute name="animationTicks" value="1"/>
        <attribute name="animatorsList" value="[]"/>
        <attribute name="commandQueue" value="[]"/>
        <attribute name="worldCols" value="120"/>
        <attribute name="worldRows" value="100"/>
        <attribute name="tileDictRows" value="null"/>
        <attribute name="codeString" type="string" value="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-"/>
        <attribute name="codeMap" value="null"/>
        <attribute name="newTilesMax" value="300"/>
        <attribute name="newTiles" value="0"/>
        <attribute name="quaking" value="0"/>
	<attribute name="connected" value="false"/>
	<attribute name="connecting" value="false"/>
	<attribute name="connectionFailed" value="false"/>
	<attribute name="gameMode" type="string" value="start"/>
	<attribute name="gap" value="5"/>
	<attribute name="nextUniqueID" value="1"/>
	<attribute name="interests" value="$once{{}}"/>
	<attribute name="worldW" value="120"/>
	<attribute name="worldH" value="100"/>


        <handler name="oninit"><![CDATA[
            var codeString = this.codeString;
            var codeMap = {};
            this.codeMap = codeMap;

            var i;
            for (i = 0; i < codeString.length; i++) {
                var c = codeString.substr(i, 1);
                codeMap[c] = i;
            }

            var tileDictRows = [];
            this.tileDictRows = tileDictRows;
            var row;
            for (row = 0; row < this.worldRows; row++) {
                var tileDictRow = new Array(this.worldCols);;
                tileDictRows.push(tileDictRow);
            }

	    this.requestStartSession();

	    // Note: We must initialize interests above in the attribute once clause.
	    // Because if we initialize it here, we are running after the children's
	    // oninit's have been run, so we would wipe out their interests. 

          ]]>
        </handler>


	<method name="expressInterest" args="target, names"><![CDATA[
	    var interests = this.interests;
	    var n = names.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var name = names[i];
		if (!(name in interests)) {
		    interests[name] = [target];
		} else {
		    var a = interests[name];
		    var j = this.indexOf(a, target);
		    if (j < 0) {
			a.push(target);
		    }
		}
	    }
	  ]]>
	</method>


	<method name="revokeInterest" args="target, names"><![CDATA[
	    var interests = this.interests;
	    var name;
	    var n = names.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var name = names[i];
		if (!(name in interests)) {
		    continue;
		}
		var a = interests[name]
		var j = this.indexOf(a, target);
		if (j >= 0) {
		    a.splice(j, 1);
		}
	    }
	  ]]>
	</method>


	<method name="indexOf" args="a, obj"><![CDATA[
	    var i;
	    var n = a.length;
	    for (i = 0; i < n; i++) {
		if (a[i] == obj) {
		    return i;
		}
	    }
	    return -1;
	  ]]>
	</method>


	<method name="makeUniqueID"><![CDATA[
	    var uniqueID = this.nextUniqueID;
	    this.nextUniqueID++;
	    return uniqueID;
	  ]]>
	</method>


	<method name="requestStartSession"><![CDATA[
	    this.setAttribute("connected", false);
	    this.setAttribute("connecting", true);
	    this.setAttribute("connectionFailed", false);

            ds_session.setAttribute("src", "/server/micropolisSessionStart");
            ds_session.doRequest();
	  ]]>
	</method>


        <method name="startSession" args="sessionID"><![CDATA[
	    this.setAttribute("connected", true);
	    this.setAttribute("connecting", false);
	    this.setAttribute("connectionFailed", false);
            this.setAttribute("sessionID", sessionID);
            this.pollStart();
	    this.animateStart();
          ]]>
        </method>


        <method name="failSession"><![CDATA[
	    this.setAttribute("connected", false);
	    this.setAttribute("connecting", false);
	    this.setAttribute("connectionFailed", true);
            this.setAttribute("sessionID", null);
	    this.setAttribute("gameMode", "start");
            this.pollStop();
	    this.animateStop();
          ]]>
        </method>


        <method name="failPoll"><![CDATA[
	    this.failSession();
          ]]>
        </method>


        <method name="addIdler" args="idler"><![CDATA[
            //Debug.write("appview addIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i < 0) {
                this.idlers.push(idler);
            }
          ]]>
        </method>


        <method name="removeIdler" args="idler"><![CDATA[
            //Debug.write("appview removeIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i >= 0) {
                this.idlers.splice(i, 1);
            }
          ]]>
        </method>


<!--
        <handler name="onidle" reference="LzIdleService.LzIdle"><![CDATA[

            this.idles++;

            var idlers = this.idlers;
            var n = idlers.length;
            var i;

	    for (i = 0; i < n; i++) {
		idlers[i].idle();
	    }

          ]]>
        </handler>
-->


        <method name="addAnimator" args="animator"><![CDATA[
            //Debug.write("appview addAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i < 0) {
                this.animatorsList.push(animator);
            }

	    if (!this.animateActive) {
	        this.animateStart();
	    }
          ]]>
        </method>


        <method name="removeAnimator" args="animator"><![CDATA[
            //Debug.write("appview removeAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i >= 0) {
                this.animatorsList.splice(i, 1);
            }

	    if (this.animateActive &&
	        this.animatorsList.length == 0) {
		this.animateStop();
	    }
          ]]>
        </method>


        <method name="animateStart"><![CDATA[
	    //Debug.write("animateStart");
            if (this.animateActive) {
                //Debug.write("animateStart already started");
                return;
            }
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            var t = lz.Timer.addTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
          ]]>
        </method>


        <method name="animateContinue"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor animateStart and animateContinue.
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            lz.Timer.resetTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
            //Debug.write("animateContinue");
          ]]>
        </method>


        <method name="animateStop"><![CDATA[
	    //Debug.write("animateStop");
            if (!this.animateActive) {
                return;
            }
            lz.Timer.removeTimer(this.animateDelegate);
	    this.animateActive = false;
          ]]>
        </method>


	<method name="doAnimate" args="ignore"><![CDATA[

	    //Debug.write("doAnimate");

	    this.animationTicks++;
	    this.newTiles = 0;

	    //this.animateTiles();

            var animatorsList = this.animatorsList;
            var n = animatorsList.length;
	    var i;
	    for (i = 0; i < n; i++) {
	        animatorsList[i].doAnimate();
	    }

	    this.animateContinue();

	  ]]>
	</method>


        <method name="addPoller" args="poller"><![CDATA[
            //Debug.write("appview addPoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i < 0) {
                this.pollers.push(poller);
            }
          ]]>
        </method>


        <method name="removePoller" args="poller"><![CDATA[
            //Debug.write("appview removePoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i >= 0) {
                this.pollers.splice(i, 1);
            }
          ]]>
        </method>


        <method name="pollStart"><![CDATA[
            if (this.pollActive) {
                //Debug.write("pollStart already started");
                return;
            }
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            var t = lz.Timer.addTimer(this.pollDelegate, this.pollDelay);
            this.pollActive = true;
          ]]>
        </method>


        <method name="pollContinue" args="soon"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor pollStart and pollContinue.
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            lz.Timer.resetTimer(this.pollDelegate, soon ? this.pollDelaySoon : this.pollDelay);
            this.pollActive = true;
            //Debug.write("pollContinue");
          ]]>
        </method>


        <method name="pollStop"><![CDATA[
            if (!this.pollActive) {
                return;
            }
            lz.Timer.removeTimer(this.pollDelegate);
	    this.pollActive = false;
          ]]>
        </method>


        <method name="poll" args="ignore"><![CDATA[
            var i, n;
            var body = [];

            var ref = this.polls;
            this.polls++;

            body.push("<poll ref=\"" + ref + "\" sessionID=\"" + this.sessionID + "\">");

            var pollers = this.pollers;
            n = pollers.length;
            if (n > 0) {
                body.push("<pollers>")
                for (i = 0; i < n; i++) {
                    body.push(pollers[i].poll());
                }
                body.push("</pollers>");
            }

            var commandQueue = this.commandQueue;
            if (commandQueue && commandQueue.length > 0) {
                this.commandQueue = [];
                body.push("<commands>");
                n = commandQueue.length;
                for (i = 0; i < n; i++) {
                    var command = commandQueue[i];
                    body.push(command);
                }
                body.push("</commands>");
            }

            body.push("</poll>");

	    body = body.join("");

            //Debug.write(body);

            var params = {
                ref: ref,
                sessionID: this.sessionID,
                rand: Math.random(),
                body: body
            };

	    this.pollStop();

            ds_poll.setAttribute("src", "/server/micropolisPoll");
            ds_poll.setQueryParams(params);
            ds_poll.setAttribute("querytype", "post");
            ds_poll.doRequest();

          ]]>
        </method>


        <method name="sendCommand" args="command"><![CDATA[
            Debug.write("$$$$ sendCommand", command);
            this.commandQueue.push(command);
          ]]>
        </method>


	<method name="setDescription" args="txt"><![CDATA[
	    this.startScreen.v1.descriptionView.description.setAttribute("text", txt);
	  ]]>
	</method>


        <method name="updateTiles" args="col, row, cols, rows, format, codedTiles"><![CDATA[
            //Debug.write("row", row, "col", col, "rows", rows, "cols", cols, "format", format);
            //Debug.write("codedTiles.length", codedTiles.length, codedTiles.substr(0, 20));

            var tileDictRows = this.tileDictRows;
            var codeMap = this.codeMap;

            switch (format) {

                case 0: {
                    var lastCol = col + cols;
                    var lastRow = row + rows;
                    var r, c;
                    var codeOffset = 0;
                    for (r = row; r < lastRow; r++) {
                        var tileDictRow = tileDictRows[r];
                        for (c = col; c < lastCol; c++) {
                            var c1 = 
                                codedTiles.substr(codeOffset, 1);
                            var c2 =
                                codedTiles.substr(codeOffset + 1, 1);
                            var tileIndex = 
                                (((codeMap[c2] * 64) + codeMap[c1]) & 1023);

                            var tileDict = tileDictRow[c];
                            if (!tileDict) {
                                tileDict = {
                                    'animationTicks': -1
                                };
                                tileDictRow[c] = tileDict;
                            }

                            tileDict['index'] = tileIndex;
                            tileDict['animated'] = gAniTiles[tileIndex] != tileIndex;

                            codeOffset += 2;
                        }
                    }
                    break;
                }

                case 1: {
                    var tileOffset = 0;
                    var tileOffsetMax = rows * cols;
                    var codeOffset = 0;
                    var codeOffsetMax = codedTiles.length;

                    function getNumber1()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset += 1;
                        return codeMap[c1];
                    }

                    function getNumber2()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        codeOffset += 2;
                        return codeMap[c1] + (codeMap[c2] * 64);
                    }

                    function getNumber3()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        var c3 = codedTiles.substr(codeOffset + 2, 1);
                        codeOffset += 3;
                        return codeMap[c1] + (codeMap[c2] * 64) + (codeMap[c2] * 4096);
                    }

		    var charHandlers = {
			'.': function() { tileOffset += 1; },
			':': function() { tileOffset += 2; },
			',': function() { tileOffset += 3; },
			';': function() { tileOffset += 4; },
			'!': function() { tileOffset += getNumber1() + 2; },
			'@': function() { tileOffset += getNumber2() + 2; },
			'#': function() { tileOffset += getNumber3() + 2; }
		    };

                    while ((tileOffset >= 0) && 
                           (tileOffset < tileOffsetMax) &&
                           (codeOffset < codeOffsetMax)) {

                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset++;

			var charHandler = charHandlers[c1];
			if (charHandler) {
			    charHandler();
			    continue;
			}

                        var c2 = codedTiles.substr(codeOffset, 1);
                        codeOffset++

                        var tileIndex = 
                            (codeMap[c1] + (codeMap[c2] * 64));

                        var c = tileOffset % cols;
                        var r = Math.floor(tileOffset / cols);

                        var tileDictRow = tileDictRows[row + r];
                        var tileDict = tileDictRow[col + c];
                        
                        if (!tileDict) {
                            tileDict = {
                                'animationTicks': -1
                            };
                            tileDictRow[col + c] = tileDict;
                        }

                        tileDict['index'] = tileIndex;
                        tileDict['animated'] = gAniTiles[tileIndex] != tileIndex;

                        tileOffset++;

                    }
                    break;
                }

            }
          ]]>
        </method>


        <method name="animateTiles"><![CDATA[

            var cols = this.worldCols;
            var rows = this.worldRows;
            var tileDictRows = this.tileDictRows;
            var r, c;
            for (r = 0; r < rows; r++) {
                var tileDictRow = tileDictRows[r];
                for (c = 0; c < cols; c++) {
                    var tileDict = tileDictRow[c];
                    if (tileDict === null) {
                        continue;
                    }
                    var nextTileIndex = gAniTiles[tileDict];
                    if (tileDict != nextTileIndex) {
                        //Debug.write(c, r, cols, rows, tileDict, nextTileIndex);
                        tileDictRow[c] = nextTileIndex;
                    }
                }
            }
          ]]>
        </method>


        <method name="getTileDict" args="col, row"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            var tileDict = tileDictRow[col];
            return tileDict;
          ]]>
        </method>


        <method name="setTileDict" args="col, row, tileDict"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            tileDictRow[col] = tileDict;
          ]]>
        </method>


	<method name="resetCity"><![CDATA[

	    // TODO: Reset stuff for a new city.

	    this.setAttribute("quaking", 0);

	  ]]>
        </method>


	<method name="handle_UIUpdate" args="args"><![CDATA[
	    var aspect = args['aspect'];
	    var interests = this.interests;
	    //Debug.write("**** UIUpdate", aspect, args);
	    
	    if (!(aspect in interests)) {
	       return;
	    }

	    var a = interests[aspect];
	    //Debug.write("UPDATE ASPECT", aspect, a, args);
	    var n = a.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var target = a[i];
	        target.handleUpdate(args);
	    }
	  ]]>
	</method>


	<method name="handle_UIDidGenerateNewCity" args="args"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadCity" args="args"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadScenario" args="args"><![CDATA[
	    this.resetCity();
            var scenario = args['scenario'];
	    var number = 49 + scenario;
	    gNoticeView.setCurrentNotice(number, null, null);
	  ]]>
	</method>


	<method name="handle_UIStartEarthquake" args="args"><![CDATA[
	    this.setAttribute("quaking", parseInt(args['magnitude']));
	  ]]>
	</method>


	<method name="handle_UIStopEarthquake" args="args"><![CDATA[
	    this.setAttribute("quaking", 0);
	  ]]>
	</method>


	<method name="handle_UIShowBudgetAndWait" args="args"><![CDATA[
	    Debug.write("Show budget and wait...");
	  ]]>
	</method>


	<method name="handle_UIMakeSound" args="args"><![CDATA[
	    var channel = args['channel'];
	    var sound = args['sound'];
	    Debug.write("MAKE SOUND", "channel", channel, "sound", sound);
	  ]]>
	</method>


	<method name="handle_UINewGame" args="args"><![CDATA[
	    Debug.write("UINewGame");
	  ]]>
	</method>


	<method name="playWithThisCity"><![CDATA[
	    this.setAttribute("gameMode", "play");
	    this.sendCommand('<command name="setGameMode" gameMode="play"/>');
	  ]]>
	</method>


	<method name="chooseCity"><![CDATA[
	    this.setAttribute("gameMode", "start");
	    this.sendCommand('<command name="setGameMode" gameMode="start"/>');
	  ]]>
	</method>


        <node id="gSessionData"
            datapath="ds_session:/session"
        >


            <attribute name="sessionID" type="string" value="$path{'@sessionID'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_session ondata", this.sessionID);
                classroot.startSession(this.sessionID);
              ]]>
            </handler>


            <handler name="onerror" reference="ds_session"><![CDATA[
                Debug.write("ds_session onerror", this.sessionID);
                classroot.failSession();
              ]]>
            </handler>


            <handler name="ontimeout" reference="ds_session"><![CDATA[
                Debug.write("ds_session ontimeout", this.sessionID);
                classroot.failSession();
              ]]>
            </handler>


        </node>


        <node id="pollData"
            datapath="ds_poll:/poll"
        >


            <attribute name="ref" value="$path{'@ref'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_poll");

                var poll = ds_poll.data;
                var pollChildren = poll['childNodes'];
                if (pollChildren && (pollChildren.length > 0)) {
                    var i;
                    var n = pollChildren.length;
                    for (i = 0; i < n; i++) {
                        var pollChild = pollChildren[i];
                        if (pollChild.nodeType != 1) {
                            continue;
                        }

			//Debug.write(pollChild.nodeName, pollChild);

                        switch (pollChild.nodeName) {

                            case "tileviews": {

                                var tileviews = pollChild['childNodes'];
                                if (!tileviews) {
                                    break;
                                }

                                //Debug.write("tileviews", tileviews);
                                if (!tileviews || tileviews.length == 0) {
                                    break;
                                }

                                var j;
                                var m = tileviews.length;
                                for (j = 0; j < m; j++) {
                                    var tileview = tileviews[j];
                                    if (tileview.nodeType != 1) {
                                        continue;
                                    }

                                    var attributes = tileview.attributes;

                                    //Debug.write("tileview", attributes);

                                    var col = parseInt(attributes['col']);
                                    var row = parseInt(attributes['row']);
                                    var cols = parseInt(attributes['cols']);
                                    var rows = parseInt(attributes['rows']);
                                    var format = parseInt(attributes['format']);
                                    var children = tileview['childNodes'];
                                    var codedTiles = (children && (children.length > 0)) ? children[0].data : "";

                                    //Debug.write(col, row, cols, rows, format, codedTiles);

                                    if (!isNaN(col) &&
                                        !isNaN(row) &&
                                        !isNaN(cols) &&
                                        !isNaN(rows) &&
                                        !isNaN(format) &&
                                        (rows > 0) &&
                                        (cols > 0) &&
                                        (codedTiles != "")) {
                                        classroot.updateTiles(
                                            col,
                                            row,
                                            cols,
                                            rows,
                                            format,
                                            codedTiles);
                                    }
                                }

                                break;
                            }

                            case "messages": {

                                var messages = pollChild['childNodes'];
                                if (!messages || (messages.length == 0)) {
                                    break;
                                }

				var j;
				var m = messages.length;
				for (j = 0; j < m; j++) {
				    var messageEl = messages[j];
				    var attributes = messageEl.attributes;
				    var messageName = attributes['message'];
				    if (!messageName) {
					continue;
				    }
				    var methodName = "handle_" + messageName;
				    var method = classroot[methodName];
				    //Debug.write("message", messageName, "method", methodName, method, "atts", attributes, "el", messageEl);
				    if (!method) {
					Debug.write("Undefined message:", messageName, messageEl, attributes);
					continue;
				    }
				    var text =
				    	messageEl.childNodes &&
					messageEl.childNodes[0];
				    var json = null;
				    if (text == null) {
					json = null;
				    } else {
				        json = JSON.parse(text);
				    }

				    //Debug.write("JSON", json)

				    method.call(classroot, json);
				}

				break;
			    }

                        }

                    }
                }

                classroot.pollContinue(false);
              ]]>
            </handler>


            <handler name="onerror" reference="ds_poll"><![CDATA[
                Debug.write("ds_poll onerror", this.sessionID);
                classroot.failPoll();
              ]]>
            </handler>


            <handler name="ontimeout" reference="ds_poll"><![CDATA[
                Debug.write("ds_poll ontimeout", this.sessionID);
                classroot.failPoll();
              ]]>
            </handler>


        </node>


	<connectscreen id="gConnectScreen" name="connectScreen"
	    x="5"
	    y="5"
	    width="${parent.width - 10}"
	    height="${parent.height - 10}"
	    visible="${!classroot.connected}"
	/>

	<startscreen id="gStartScreen" name="startScreen"
	    x="5"
	    y="5"
	    width="${parent.width - 10}"
	    height="${parent.height - 10}"
	    visible="${(classroot.gameMode == 'start') &amp;&amp; classroot.connected}"
	/>

	<playscreen id="gPlayScreen" name="playScreen"
	    x="0"
	    y="0"
	    width="${parent.width}"
	    height="${parent.height}"
	    visible="${(classroot.gameMode == 'play') &amp;&amp; classroot.connected}"
	/>


    </class>


</library>
