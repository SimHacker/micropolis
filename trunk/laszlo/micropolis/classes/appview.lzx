<library>


    <!-- Application View -->
    <!-- Written for Micropolis -->
    <!-- By Don Hopkins -->
    <!-- Licensed under GPLv3 -->


    <class name="appview">


        <attribute name="pollDelay" value="50"/>
        <attribute name="pollActive" value="false"/>
        <attribute name="pollDelegate" value="null"/>
        <attribute name="polls" value="1"/>
        <attribute name="pollers" value="[]"/>
        <attribute name="idles" value="1"/>
        <attribute name="idlers" value="[]"/>
        <attribute name="panelWidth" value="200"/>
        <attribute name="panelResizeBarX" value="200"/>
        <attribute name="panelResizeBar1Y" value="200"/>
        <attribute name="panelResizeBar2Y" value="$once{parent.height - 200}"/>
        <attribute name="panelResizeBarSize" value="16"/>
        <attribute name="commandQueue" value="[]"/>
        <attribute name="nextUniqueID" value="1"/>
        <attribute name="worldCols" value="120"/>
        <attribute name="worldRows" value="100"/>
        <attribute name="tileDictRows" value="null"/>
        <attribute name="codeString" type="string" value="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-"/>
        <attribute name="codeMap" value="null"/>
        <attribute name="aniTiles" value="null"/>
        <attribute name="newTilesMax" value="300"/>
        <attribute name="newTiles" value="0"/>
        <attribute name="quaking" value="0"/>


        <handler name="oninit"><![CDATA[
            var codeString = this.codeString;
            var codeMap = {};
            this.codeMap = codeMap;

            var i;
            for (i = 0; i < codeString.length; i++) {
                var c = codeString.substr(i, 1);
                codeMap[c] = i;
            }

            var tileDictRows = [];
            this.tileDictRows = tileDictRows;
            var row;
            for (row = 0; row < this.worldRows; row++) {
                var tileDictRow = new Array(this.worldCols);;
                tileDictRows.push(tileDictRow);
            }

            this.aniTiles = [
                0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,
                16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31, 
                32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
                48,  49,  50,  51,  52,  53,  54,  55,
                // Fire
                                                        57,  58,  59,  60,  61,  62,  63,  56,
                // No Traffic
                64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
                // Light Traffic
                128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
                80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
                96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
                112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
                // Heavy Traffic
                192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
                144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
                160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
                176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
                // Wires & Rails
                208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
                224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
                // Residential
                240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
                256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271,
                272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287,
                288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303,
                304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319,
                320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335,
                336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351,
                352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367,
                368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383,
                384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399,
                400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415,
                416, 417, 418, 419, 420, 421, 422,
                // Commercial
                                                   423, 424, 425, 426, 427, 428, 429, 430, 431,
                432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447,
                448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463,
                464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479,
                480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495,
                496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511,
                512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
                528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543,
                544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559,
                560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575,
                576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591,
                592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607,
                608, 609, 610, 611,
                // Industrial
                                    612, 613, 614, 615, 616, 617, 618, 619, 852, 621, 622, 623,
                624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639,
                640, 884, 642, 643, 888, 645, 646, 647, 648, 892, 896, 651, 652, 653, 654, 655,
                656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671,
                672, 673, 674, 675, 900, 904, 678, 679, 680, 681, 682, 683, 684, 685, 908, 687,
                688, 912, 690, 691, 692,
                // SeaPort
                                         693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703,
                704, 705, 706, 707, 708,
                // AirPort
                                         709, 710, 832, 712, 713, 714, 715, 716, 717, 718, 719,
                720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735,
                736, 737, 738, 739, 740, 741, 742, 743, 744,
                // Coal power
                                                             745, 746, 916, 920, 749, 750, 924,
                928, 753, 754, 755, 756, 757, 758, 759, 760,
                // Fire Dept
                                                             761, 762, 763, 764, 765, 766, 767,
                768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778,
                // Stadium
                                                                       779, 780, 781, 782, 783,
                784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794,
                // Stadium Anims
                                                                       795, 796, 797, 798, 799,
                800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810,
                // Nuclear Power
                                                                       811, 812, 813, 814, 815,
                816, 817, 818, 819, 952, 821, 822, 823, 824, 825, 826,
                // Power out + Bridges
                                                                       827, 828, 829, 830, 831,
                // Radar dish
                833, 834, 835, 836, 837, 838, 839, 832,
                // Fountain / Flag
                                                        841, 842, 843, 840, 845, 846, 847, 848,
                849, 850, 851, 844, 853, 854, 855, 856, 857, 858, 859, 852,
                // zone destruct & rubblize
                                                                            861, 862, 863, 864,
                865, 866, 867, 867,
                // totally unsure
                                    868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879,
                880, 881, 882, 883,
                // Smoke stacks
                                    885, 886, 887, 884, 889, 890, 891, 888, 893, 894, 895, 892,
                897, 898, 899, 896, 901, 902, 903, 900, 905, 906, 907, 904, 909, 910, 911, 908,
                913, 914, 915, 912, 917, 918, 919, 916, 921, 922, 923, 920, 925, 926, 927, 924,
                929, 930, 931, 928,
                // Stadium Playfield
                                    933, 934, 935, 936, 937, 938, 939, 932, 941, 942, 943, 944,
                945, 946, 947, 940,
                // Bridge up chars
                                    948, 949, 950, 951,
                // Nuclear swirl
                                                        953, 954, 955, 952
            ];

            ds_session.setAttribute("src", "/server/micropolisSessionStart");
            ds_session.doRequest();
          ]]>
        </handler>


        <method name="makeUniqueID"><![CDATA[
            var uniqueID = this.nextUniqueID;
            this.nextUniqueID++;
            return uniqueID;
          ]]>
        </method>


        <method name="startSession" args="sessionID"><![CDATA[
            this.setAttribute("sessionID", sessionID);
            this.pollStart();
          ]]>
        </method>


        <method name="indexOf" args="a, obj"><![CDATA[
            var i;
            var n = a.length;
            for (i = 0; i < n; i++) {
                if (a[i] == obj) {
                    return i;
                }
            }
            return -1;
          ]]>
        </method>


        <method name="addIdler" args="idler"><![CDATA[
            //Debug.write("appview addIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i < 0) {
                this.idlers.push(idler);
            }
          ]]>
        </method>


        <method name="removeIdler" args="idler"><![CDATA[
            //Debug.write("appview removeIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i >= 0) {
                this.idlers.splice(i, 1);
            }
          ]]>
        </method>


        <handler name="onidle" reference="LzIdleService.LzIdle"><![CDATA[

	    var dx = 0;
	    var dy = 0;
	    var quaking = this.quaking;
	    if (quaking > 0) {
		dx = (Math.random() * quaking) - (quaking / 2);
		dy = (Math.random() * quaking) - (quaking / 2);
		quaking *= 0.9;
		if (quaking < 1) {
		    quaking = 0;
		}
		this.quaking = quaking;
	    }
	    this.top.setAttribute("x", dx, true);
	    this.top.setAttribute("y", dy, true);

            this.newTiles = 0;
            this.idles++;

            var idlers = this.idlers;
            var n = idlers.length;
            var i;

            // TODO: For now, zero idlers means zero viewers of tiles, but that might change. 
            // TODO: Only animate tiles if anyone is viewing them, but call idlers anyway.
            if (n > 0) {
                for (i = 0; i < n; i++) {
                    idlers[i].idle();
                }
            }

          ]]>
        </handler>


        <method name="addPoller" args="poller"><![CDATA[
            //Debug.write("appview addPoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i < 0) {
                this.pollers.push(poller);
            }
          ]]>
        </method>


        <method name="removePoller" args="poller"><![CDATA[
            //Debug.write("appview removePoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i >= 0) {
                this.pollers.splice(i, 1);
            }
          ]]>
        </method>


        <method name="pollStart"><![CDATA[
            if (this.pollActive) {
                //Debug.write("pollStart already started");
                return;
            }
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            var t = lz.Timer.addTimer(this.pollDelegate, this.pollDelay);
            this.pollActive = true;
          ]]>
        </method>


        <method name="pollContinue" args="soon"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor pollStart and pollContinue.
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            lz.Timer.resetTimer(this.pollDelegate, soon ? this.pollDelaySoon : this.pollDelay);
            this.pollActive = true;
            //Debug.write("pollContinue");
          ]]>
        </method>


        <method name="pollStop"><![CDATA[
            if (!this.pollActive) {
                return;
            }
            lz.Timer.removeTimer(this.pollDelegate);
          ]]>
        </method>


        <method name="poll" args="ignore"><![CDATA[
            var i, n;
            var body = [];

            var ref = this.polls;
            this.polls++;

            body.push("<poll ref=\"" + ref + "\" sessionID=\"" + this.sessionID + "\">");

            var pollers = this.pollers;
            n = pollers.length;
            if (n > 0) {
                body.push("<pollers>")
                for (i = 0; i < n; i++) {
                    body.push(pollers[i].poll());
                }
                body.push("</pollers>");
            }

            var commandQueue = this.commandQueue;
            if (commandQueue && commandQueue.length > 0) {
                this.commandQueue = [];
                body.push("<commands>");
                n = commandQueue.length;
                for (i = 0; i < n; i++) {
                    var command = commandQueue[i];
                    body.push(command);
                }
                body.push("</commands>");
            }

            body.push("</poll>");

	    body = body.join("");

            //Debug.write(body);

            var params = {
                ref: ref,
                sessionID: this.sessionID,
                rand: Math.random(),
                body: body
            };

            ds_poll.setAttribute("src", "/server/micropolisPoll");
            ds_poll.setQueryParams(params);
            ds_poll.setAttribute("querytype", "post");
            ds_poll.doRequest();

          ]]>
        </method>


        <method name="sendCommand" args="command"><![CDATA[
            Debug.write("sendCommand", command);
            this.commandQueue.push(command);
          ]]>
        </method>


        <method name="updateTiles" args="col, row, cols, rows, format, codedTiles"><![CDATA[
            //Debug.write("row", row, "col", col, "rows", rows, "cols", cols, "format", format);
            //Debug.write("codedTiles.length", codedTiles.length, codedTiles.substr(0, 20));

            var tileDictRows = this.tileDictRows;
            var codeMap = this.codeMap;
            var aniTiles = this.aniTiles;

            switch (format) {

                case 0: {
                    var lastCol = col + cols;
                    var lastRow = row + rows;
                    var r, c;
                    var codeOffset = 0;
                    for (r = row; r < lastRow; r++) {
                        var tileDictRow = tileDictRows[r];
                        for (c = col; c < lastCol; c++) {
                            var c1 = 
                                codedTiles.substr(codeOffset, 1);
                            var c2 =
                                codedTiles.substr(codeOffset + 1, 1);
                            var tileIndex = 
                                (((codeMap[c2] * 64) + codeMap[c1]) & 1023);

                            var tileDict = tileDictRow[c];
                            if (!tileDict) {
                                tileDict = {
                                    'idles': -1
                                };
                                tileDictRow[c] = tileDict;
                            }

                            tileDict['index'] = tileIndex;
                            tileDict['animated'] = aniTiles[tileIndex] != tileIndex;

                            codeOffset += 2;
                        }
                    }
                    break;
                }

                case 1: {
                    var tileOffset = 0;
                    var tileOffsetMax = rows * cols;
                    var codeOffset = 0;
                    var codeOffsetMax = codedTiles.length;

                    function getNumber1()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset += 1;
                        return codeMap[c1];
                    }

                    function getNumber2()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        codeOffset += 2;
                        return codeMap[c1] + (codeMap[c2] * 64);
                    }

                    function getNumber3()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        var c3 = codedTiles.substr(codeOffset + 2, 1);
                        codeOffset += 3;
                        return codeMap[c1] + (codeMap[c2] * 64) + (codeMap[c2] * 4096);
                    }

                    while ((tileOffset >= 0) && 
                           (tileOffset < tileOffsetMax) &&
                           (codeOffset < codeOffsetMax)) {

                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset++;

                        if (c1 == '.') {
                            tileOffset++;
                            continue;
                        } else if (c1 == ':') {
                            tileOffset += 2;
                            continue;
                        } else if (c1 == ',') {
                            tileOffset += 3;
                            continue;
                        } else if (c1 == ';') {
                            tileOffset += 4;
                            continue;
                        } else if (c1 == '!') {
                            var skip = getNumber1() + 2;
                            tileOffset += skip;
                            continue;
                        } else if (c1 == '@') {
                            tileOffset += getNumber2() + 2;
                            continue;
                        } else if (c1 == '#') {
                            tileOffset += getNumber3() + 2;
                            continue;
                        }

                        var c2 = codedTiles.substr(codeOffset, 1);
                        codeOffset++

                        var tileIndex = 
                            (codeMap[c1] + (codeMap[c2] * 64));

                        var c = tileOffset % cols;
                        var r = Math.floor(tileOffset / cols);

                        var tileDictRow = tileDictRows[row + r];
                        var tileDict = tileDictRow[col + c];
                        
                        if (!tileDict) {
                            tileDict = {
                                'idles': -1
                            };
                            tileDictRow[col + c] = tileDict;
                        }

                        tileDict['index'] = tileIndex;
                        tileDict['animated'] = aniTiles[tileIndex] != tileIndex;

                        tileOffset++;

                    }
                    break;
                }

            }
          ]]>
        </method>


        <method name="animateTiles"><![CDATA[
            var cols = this.worldCols;
            var rows = this.worldRows;
            var aniTiles = this.aniTiles;
            var tileDictRows = this.tileDictRows;
            var r, c;
            for (r = 0; r < rows; r++) {
                var tileDictRow = tileDictRows[r];
                for (c = 0; c < cols; c++) {
                    var tileDict = tileDictRow[c];
                    if (tileDict === null) {
                        continue;
                    }
                    var nextTileIndex = aniTiles[tileDict];
                    if (tileDict != nextTileIndex) {
                        //Debug.write(c, r, cols, rows, tileDict, nextTileIndex);
                        tileDictRow[c] = nextTileIndex;
                    }
                }
            }
          ]]>
        </method>


        <method name="getTileDict" args="col, row"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            var tileDict = tileDictRow[col];
            return tileDict;
          ]]>
        </method>


        <method name="setTileDict" args="col, row, tileDict"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            tileDictRow[col] = tileDict;
          ]]>
        </method>


	<method name="resetCity"><![CDATA[

	    // TODO: Reset stuff for a new city.

	    this.setAttribute("quaking", 0);

	  ]]>
        </method>


	<method name="handle_UIDidGenerateNewCity"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadCity"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadScenario"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIStartEarthquake" args="args"><![CDATA[
	    this.setAttribute("quaking", parseInt(args['magnitude']));
	  ]]>
	</method>


	<method name="handle_UIStopEarthquake"><![CDATA[
	    this.setAttribute("quaking", 0);
	  ]]>
	</method>


	<method name="handle_UIMakeSound" args="channel, sound"><![CDATA[
	    Debug.write("MAKE SOUND", channel, sound);
	  ]]>
	</method>


        <node id="sessionData"
            datapath="ds_session:/session"
        >


            <attribute name="sessionID" type="string" value="$path{'@sessionID'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_session", this.sessionID);
                classroot.startSession(this.sessionID);
              ]]>
            </handler>


        </node>


        <node id="pollData"
            datapath="ds_poll:/poll"
        >


            <attribute name="ref" value="$path{'@ref'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_poll");

                var poll = ds_poll.data;
                var pollChildren = poll['childNodes'];
                if (pollChildren && (pollChildren.length > 0)) {
                    var i;
                    var n = pollChildren.length;
                    for (i = 0; i < n; i++) {
                        var pollChild = pollChildren[i];
                        if (pollChild.nodeType != 1) {
                            continue;
                        }

			//Debug.write(pollChild.nodeName, pollChild);

                        switch (pollChild.nodeName) {

                            case "tileviews": {

                                var tileviews = pollChild['childNodes'];
                                if (!tileviews) {
                                    break;
                                }

                                //Debug.write("tileviews", tileviews);
                                if (!tileviews || tileviews.length == 0) {
                                    break;
                                }

                                var j;
                                var m = tileviews.length;
                                for (j = 0; j < m; j++) {
                                    var tileview = tileviews[j];
                                    if (tileview.nodeType != 1) {
                                        continue;
                                    }

                                    var attributes = tileview.attributes;

                                    //Debug.write("tileview", attributes);

                                    var col = parseInt(attributes['col']);
                                    var row = parseInt(attributes['row']);
                                    var cols = parseInt(attributes['cols']);
                                    var rows = parseInt(attributes['rows']);
                                    var format = parseInt(attributes['format']);
                                    var children = tileview['childNodes'];
                                    var codedTiles = (children && (children.length > 0)) ? children[0].data : "";

                                    //Debug.write(col, row, cols, rows, format, codedTiles);

                                    if (!isNaN(col) &&
                                        !isNaN(row) &&
                                        !isNaN(cols) &&
                                        !isNaN(rows) &&
                                        !isNaN(format) &&
                                        (rows > 0) &&
                                        (cols > 0) &&
                                        (codedTiles != "")) {
                                        classroot.updateTiles(
                                            col,
                                            row,
                                            cols,
                                            rows,
                                            format,
                                            codedTiles);
                                    }
                                }

                                break;
                            }

                            case "messages": {

                                var messages = pollChild['childNodes'];
Debug.write("MESSAGES", messages);
                                if (!messages || (messages.length == 0)) {
                                    break;
                                }

				var j;
				var m = messages.length;
				for (j = 0; j < m; j++) {
				    var messageEl = messages[j];
Debug.write("messagesEl", messageEl);
				    var attributes = messageEl.attributes;
Debug.write("attributes", attributes);
				    var messageName = attributes['message'];
Debug.write("messageName", messageName);
				    if (!messageName) {
					continue;
				    }
				    var methodName = "handle_" + messageName;
				    var method = classroot[methodName];
Debug.write(classroot, methodName, method);
				    if (!method) {
					Debug.write("Undefined message:", messageName, messageEl, attributes);
					continue;
				    }
				    method.call(classroot, attributes);
				}

				break;
			    }

                        }

                    }
                }

                classroot.pollContinue(false);
              ]]>
            </handler>


        </node>

	<view name="top" id="gTop"
	    x="0"
	    y="0"
	    width="${parent.width}"
	    height="${parent.height}"
	>

	    <vresizebar name="vsep1" id="gVSep1"
	      trackvar="'panelResizeBarX'"
	      maxx="${parent.width - this.width}"
	      defaultx="$once{classroot.panelResizeBarX}"
	      x="$once{classroot.panelResizeBarX}"
	      width="${classroot.panelResizeBarSize}"
	      overhang="0"
	    />

	    <view name="tvs"
		x="${parent.vsep1.x + parent.vsep1.width}"
		y="0"
		width="${parent.width - this.x}"
		height="${parent.height}"
	    >

		<hresizebar name="hsep1" id="gHSep1"
		  trackvar="'panelResizeBar1Y'"
		  maxy="${parent.height - this.height}"
		  defaulty="$once{classroot.panelResizeBar1Y}"
		  y="$once{classroot.panelResizeBar1Y}"
		  x="0"
		  height="${classroot.panelResizeBarSize}"
		  width="${parent.width - this.x}"
		  overhang="0"
		/>

		<tileview id="tv1" name="tv1"
		    x="0"
		    y="0"
		    width="${parent.width}"
		    height="${parent.hsep1.y}"
		    bgcolor="0xBC6F56"
		/>

		<tileview id="tv2" name="tv2"
		    x="0"
		    y="${parent.hsep1.y + parent.hsep1.height}"
		    width="${parent.width}"
		    height="${parent.height - this.y}"
		    bgcolor="0xBC6F56"
		/>

	    </view>

	    <view name="left"
		x="0"
		y="0"
		width="${parent.vsep1.x}"
		height="${parent.height}"
		clip="true"
	    >

		<hresizebar name="hsep2" id="gHSep2"
		  trackvar="'panelResizeBar2Y'"
		  maxy="${parent.height - this.height}"
		  defaulty="$once{classroot.panelResizeBar2Y}"
		  y="$once{classroot.panelResizeBar2Y}"
		  x="0"
		  height="${classroot.panelResizeBarSize}"
		  width="${parent.width - this.x}"
		  overhang="0"
		/>

		<view name="cp"
		    x="0"
		    y="0"
		    width="${parent.width}"
		    height="${parent.hsep2.y}"
		    clip="true"
		>

		    <view
			x="10"
			width="${parent.width - 30}"
		    >

			<simplelayout axis="y" spacing="5"/>

			<view/>

			<controlpanel
			    width="${parent.width}"
			/>

			<newcityview
			    width="${parent.width}"
			/>

			<budgetview
			    width="${parent.width}"
			/>

			<evaluationview
			    width="${parent.width}"
			/>

			<messageview
			    width="${parent.width}"
			/>

			<graphview
			    width="${parent.width}"
			/>

			<mapview
			    width="${parent.width}"
			/>

			<view/>

		    </view>

		    <vscrollbar/>

		</view>

		<drawview id="dv" name="dv"
		    bgcolor="0x808080"
		    x="0"
		    y="${parent.hsep2.y + parent.hsep2.height}"
		    width="${parent.width}"
		    height="${parent.height - this.y}"
		/>

	    </view>

	</view>

    </class>


</library>
