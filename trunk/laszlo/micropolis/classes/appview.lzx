<library>


    <!-- Application View -->
    <!-- Written for Micropolis -->
    <!-- By Don Hopkins -->
    <!-- Licensed under GPLv3 -->


    <class name="appview">


<!--
        <attribute name="pollDelay" value="1000"/>
-->
        <attribute name="pollDelay" value="100"/>
        <attribute name="pollActive" value="false"/>
        <attribute name="pollDelegate" value="null"/>
        <attribute name="polls" value="1"/>
        <attribute name="pollers" value="[]"/>
        <attribute name="idles" value="1"/>
        <attribute name="idlers" value="[]"/>
        <attribute name="animateDelay" value="100"/>
        <attribute name="animateActive" value="false"/>
        <attribute name="animateDelegate" value="null"/>
        <attribute name="animationTicks" value="1"/>
        <attribute name="animatorsList" value="[]"/>
        <attribute name="panelWidth" value="200"/>
        <attribute name="panelResizeBarY" value="200"/>
        <attribute name="panelResizeBar2X" value="200"/>
        <attribute name="panelResizeBarSize" value="8"/>
        <attribute name="commandQueue" value="[]"/>
        <attribute name="worldCols" value="120"/>
        <attribute name="worldRows" value="100"/>
        <attribute name="tileDictRows" value="null"/>
        <attribute name="codeString" type="string" value="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-"/>
        <attribute name="codeMap" value="null"/>
        <attribute name="newTilesMax" value="300"/>
        <attribute name="newTiles" value="0"/>
        <attribute name="quaking" value="0"/>
	<attribute name="connected" value="false"/>
	<attribute name="connecting" value="false"/>
	<attribute name="connectionFailed" value="false"/>
	<attribute name="gameMode" type="string" value="start"/>
	<attribute name="demandWidth" value="60"/>
	<attribute name="demandHeight" value="80"/>
	<attribute name="gap" value="5"/>
	<attribute name="nextUniqueID" value="1"/>
	<attribute name="interests" value="$once{{}}"/>
	<attribute name="worldW" value="120"/>
	<attribute name="worldH" value="100"/>


        <handler name="oninit"><![CDATA[
            var codeString = this.codeString;
            var codeMap = {};
            this.codeMap = codeMap;

            var i;
            for (i = 0; i < codeString.length; i++) {
                var c = codeString.substr(i, 1);
                codeMap[c] = i;
            }

            var tileDictRows = [];
            this.tileDictRows = tileDictRows;
            var row;
            for (row = 0; row < this.worldRows; row++) {
                var tileDictRow = new Array(this.worldCols);;
                tileDictRows.push(tileDictRow);
            }

	    this.requestStartSession();

	    // Note: We must initialize interests above in the attribute once clause.
	    // Because if we initialize it here, we are running after the children's
	    // oninit's have been run, so we would wipe out their interests. 

          ]]>
        </handler>


	<method name="expressInterest" args="target, names"><![CDATA[
	    var interests = this.interests;
	    var n = names.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var name = names[i];
		if (!(name in interests)) {
		    interests[name] = [target];
		} else {
		    var a = interests[name];
		    var j = this.indexOf(a, target);
		    if (j < 0) {
			a.push(target);
		    }
		}
	    }
	  ]]>
	</method>


	<method name="revokeInterest" args="target, names"><![CDATA[
	    var interests = this.interests;
	    var name;
	    var n = names.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var name = names[i];
		if (!(name in interests)) {
		    continue;
		}
		var a = interests[name]
		var j = this.indexOf(a, target);
		if (j >= 0) {
		    a.splice(j, 1);
		}
	    }
	  ]]>
	</method>


	<method name="indexOf" args="a, obj"><![CDATA[
	    var i;
	    var n = a.length;
	    for (i = 0; i < n; i++) {
		if (a[i] == obj) {
		    return i;
		}
	    }
	    return -1;
	  ]]>
	</method>


	<method name="makeUniqueID"><![CDATA[
	    var uniqueID = this.nextUniqueID;
	    this.nextUniqueID++;
	    return uniqueID;
	  ]]>
	</method>


	<method name="requestStartSession"><![CDATA[
	    this.setAttribute("connected", false);
	    this.setAttribute("connecting", true);
	    this.setAttribute("connectionFailed", false);

            ds_session.setAttribute("src", "/server/micropolisSessionStart");
            ds_session.doRequest();
	  ]]>
	</method>


        <method name="startSession" args="sessionID"><![CDATA[
	    this.setAttribute("connected", true);
	    this.setAttribute("connecting", false);
	    this.setAttribute("connectionFailed", false);
            this.setAttribute("sessionID", sessionID);
            this.pollStart();
	    this.animateStart();
          ]]>
        </method>


        <method name="failSession"><![CDATA[
	    this.setAttribute("connected", false);
	    this.setAttribute("connecting", false);
	    this.setAttribute("connectionFailed", true);
            this.setAttribute("sessionID", null);
            this.pollStop();
	    this.animateStop();
          ]]>
        </method>


        <method name="failPoll"><![CDATA[
	    this.failSession();
          ]]>
        </method>


        <method name="addIdler" args="idler"><![CDATA[
            //Debug.write("appview addIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i < 0) {
                this.idlers.push(idler);
            }
          ]]>
        </method>


        <method name="removeIdler" args="idler"><![CDATA[
            //Debug.write("appview removeIdler", idler);
            var i = this.indexOf(this.idlers, idler);
            if (i >= 0) {
                this.idlers.splice(i, 1);
            }
          ]]>
        </method>


<!--
        <handler name="onidle" reference="LzIdleService.LzIdle"><![CDATA[

            this.idles++;

            var idlers = this.idlers;
            var n = idlers.length;
            var i;

	    for (i = 0; i < n; i++) {
		idlers[i].idle();
	    }

          ]]>
        </handler>
-->


        <method name="addAnimator" args="animator"><![CDATA[
            //Debug.write("appview addAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i < 0) {
                this.animatorsList.push(animator);
            }

	    if (!this.animateActive) {
	        this.animateStart();
	    }
          ]]>
        </method>


        <method name="removeAnimator" args="animator"><![CDATA[
            //Debug.write("appview removeAnimator", animator);
            var i = this.indexOf(this.animatorsList, animator);
            if (i >= 0) {
                this.animatorsList.splice(i, 1);
            }

	    if (this.animateActive &&
	        this.animatorsList.length == 0) {
		this.animateStop();
	    }
          ]]>
        </method>


        <method name="animateStart"><![CDATA[
	    //Debug.write("animateStart");
            if (this.animateActive) {
                //Debug.write("animateStart already started");
                return;
            }
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            var t = lz.Timer.addTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
          ]]>
        </method>


        <method name="animateContinue"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor animateStart and animateContinue.
            if (!this.animateDelegate) {
                this.animateDelegate = new lz.Delegate(this, 'doAnimate');
            }
            lz.Timer.resetTimer(this.animateDelegate, this.animateDelay);
            this.animateActive = true;
            //Debug.write("animateContinue");
          ]]>
        </method>


        <method name="animateStop"><![CDATA[
	    //Debug.write("animateStop");
            if (!this.animateActive) {
                return;
            }
            lz.Timer.removeTimer(this.animateDelegate);
	    this.animateActive = false;
          ]]>
        </method>


	<method name="doAnimate" args="ignore"><![CDATA[

	    //Debug.write("doAnimate");

	    this.animationTicks++;
	    this.newTiles = 0;

	    //this.animateTiles();

            var animatorsList = this.animatorsList;
            var n = animatorsList.length;
	    var i;
	    for (i = 0; i < n; i++) {
	        animatorsList[i].doAnimate();
	    }

	    this.animateContinue();

	  ]]>
	</method>


        <method name="addPoller" args="poller"><![CDATA[
            //Debug.write("appview addPoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i < 0) {
                this.pollers.push(poller);
            }
          ]]>
        </method>


        <method name="removePoller" args="poller"><![CDATA[
            //Debug.write("appview removePoller", poller);
            var i = this.indexOf(this.pollers, poller);
            if (i >= 0) {
                this.pollers.splice(i, 1);
            }
          ]]>
        </method>


        <method name="pollStart"><![CDATA[
            if (this.pollActive) {
                //Debug.write("pollStart already started");
                return;
            }
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            var t = lz.Timer.addTimer(this.pollDelegate, this.pollDelay);
            this.pollActive = true;
          ]]>
        </method>


        <method name="pollContinue" args="soon"><![CDATA[
            // This is a bit confused, and violates DRY. Refactor pollStart and pollContinue.
            if (!this.pollDelegate) {
                this.pollDelegate = new lz.Delegate(this, 'poll');
            }
            lz.Timer.resetTimer(this.pollDelegate, soon ? this.pollDelaySoon : this.pollDelay);
            this.pollActive = true;
            //Debug.write("pollContinue");
          ]]>
        </method>


        <method name="pollStop"><![CDATA[
            if (!this.pollActive) {
                return;
            }
            lz.Timer.removeTimer(this.pollDelegate);
	    this.pollActive = false;
          ]]>
        </method>


        <method name="poll" args="ignore"><![CDATA[
            var i, n;
            var body = [];

            var ref = this.polls;
            this.polls++;

            body.push("<poll ref=\"" + ref + "\" sessionID=\"" + this.sessionID + "\">");

            var pollers = this.pollers;
            n = pollers.length;
            if (n > 0) {
                body.push("<pollers>")
                for (i = 0; i < n; i++) {
                    body.push(pollers[i].poll());
                }
                body.push("</pollers>");
            }

            var commandQueue = this.commandQueue;
            if (commandQueue && commandQueue.length > 0) {
                this.commandQueue = [];
                body.push("<commands>");
                n = commandQueue.length;
                for (i = 0; i < n; i++) {
                    var command = commandQueue[i];
                    body.push(command);
                }
                body.push("</commands>");
            }

            body.push("</poll>");

	    body = body.join("");

            //Debug.write(body);

            var params = {
                ref: ref,
                sessionID: this.sessionID,
                rand: Math.random(),
                body: body
            };

	    this.pollStop();

            ds_poll.setAttribute("src", "/server/micropolisPoll");
            ds_poll.setQueryParams(params);
            ds_poll.setAttribute("querytype", "post");
            ds_poll.doRequest();

          ]]>
        </method>


        <method name="sendCommand" args="command"><![CDATA[
            Debug.write("$$$$ sendCommand", command);
            this.commandQueue.push(command);
          ]]>
        </method>


	<method name="setDescription" args="txt"><![CDATA[
	    this.startScreen.v1.descriptionView.description.setAttribute("text", txt);
	  ]]>
	</method>


        <method name="updateTiles" args="col, row, cols, rows, format, codedTiles"><![CDATA[
            //Debug.write("row", row, "col", col, "rows", rows, "cols", cols, "format", format);
            //Debug.write("codedTiles.length", codedTiles.length, codedTiles.substr(0, 20));

            var tileDictRows = this.tileDictRows;
            var codeMap = this.codeMap;

            switch (format) {

                case 0: {
                    var lastCol = col + cols;
                    var lastRow = row + rows;
                    var r, c;
                    var codeOffset = 0;
                    for (r = row; r < lastRow; r++) {
                        var tileDictRow = tileDictRows[r];
                        for (c = col; c < lastCol; c++) {
                            var c1 = 
                                codedTiles.substr(codeOffset, 1);
                            var c2 =
                                codedTiles.substr(codeOffset + 1, 1);
                            var tileIndex = 
                                (((codeMap[c2] * 64) + codeMap[c1]) & 1023);

                            var tileDict = tileDictRow[c];
                            if (!tileDict) {
                                tileDict = {
                                    'animationTicks': -1
                                };
                                tileDictRow[c] = tileDict;
                            }

                            tileDict['index'] = tileIndex;
                            tileDict['animated'] = gAniTiles[tileIndex] != tileIndex;

                            codeOffset += 2;
                        }
                    }
                    break;
                }

                case 1: {
                    var tileOffset = 0;
                    var tileOffsetMax = rows * cols;
                    var codeOffset = 0;
                    var codeOffsetMax = codedTiles.length;

                    function getNumber1()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset += 1;
                        return codeMap[c1];
                    }

                    function getNumber2()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        codeOffset += 2;
                        return codeMap[c1] + (codeMap[c2] * 64);
                    }

                    function getNumber3()
                    {
                        var c1 = codedTiles.substr(codeOffset, 1);
                        var c2 = codedTiles.substr(codeOffset + 1, 1);
                        var c3 = codedTiles.substr(codeOffset + 2, 1);
                        codeOffset += 3;
                        return codeMap[c1] + (codeMap[c2] * 64) + (codeMap[c2] * 4096);
                    }

		    var charHandlers = {
			'.': function() { tileOffset += 1; },
			':': function() { tileOffset += 2; },
			',': function() { tileOffset += 3; },
			';': function() { tileOffset += 4; },
			'!': function() { tileOffset += getNumber1() + 2; },
			'@': function() { tileOffset += getNumber2() + 2; },
			'#': function() { tileOffset += getNumber3() + 2; }
		    };

                    while ((tileOffset >= 0) && 
                           (tileOffset < tileOffsetMax) &&
                           (codeOffset < codeOffsetMax)) {

                        var c1 = codedTiles.substr(codeOffset, 1);
                        codeOffset++;

			var charHandler = charHandlers[c1];
			if (charHandler) {
			    charHandler();
			    continue;
			}

                        var c2 = codedTiles.substr(codeOffset, 1);
                        codeOffset++

                        var tileIndex = 
                            (codeMap[c1] + (codeMap[c2] * 64));

                        var c = tileOffset % cols;
                        var r = Math.floor(tileOffset / cols);

                        var tileDictRow = tileDictRows[row + r];
                        var tileDict = tileDictRow[col + c];
                        
                        if (!tileDict) {
                            tileDict = {
                                'animationTicks': -1
                            };
                            tileDictRow[col + c] = tileDict;
                        }

                        tileDict['index'] = tileIndex;
                        tileDict['animated'] = gAniTiles[tileIndex] != tileIndex;

                        tileOffset++;

                    }
                    break;
                }

            }
          ]]>
        </method>


        <method name="animateTiles"><![CDATA[

            var cols = this.worldCols;
            var rows = this.worldRows;
            var tileDictRows = this.tileDictRows;
            var r, c;
            for (r = 0; r < rows; r++) {
                var tileDictRow = tileDictRows[r];
                for (c = 0; c < cols; c++) {
                    var tileDict = tileDictRow[c];
                    if (tileDict === null) {
                        continue;
                    }
                    var nextTileIndex = gAniTiles[tileDict];
                    if (tileDict != nextTileIndex) {
                        //Debug.write(c, r, cols, rows, tileDict, nextTileIndex);
                        tileDictRow[c] = nextTileIndex;
                    }
                }
            }
          ]]>
        </method>


        <method name="getTileDict" args="col, row"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            var tileDict = tileDictRow[col];
            return tileDict;
          ]]>
        </method>


        <method name="setTileDict" args="col, row, tileDict"><![CDATA[
            var tileDictRows = this.tileDictRows;
            var tileDictRow = tileDictRows[row];
            tileDictRow[col] = tileDict;
          ]]>
        </method>


	<method name="resetCity"><![CDATA[

	    // TODO: Reset stuff for a new city.

	    this.setAttribute("quaking", 0);

	  ]]>
        </method>


	<method name="handle_UIUpdate" args="args"><![CDATA[
	    var aspect = args['aspect'];
	    var interests = this.interests;
	    //Debug.write("UIUpdate", aspect, args);
	    
	    if (!(aspect in interests)) {
	       return;
	    }

	    var a = interests[aspect];
	    var n = a.length;
	    var i;
	    for (i = 0; i < n; i++) {
	    	var target = a[i];
	        target.handleUpdate(args);
	    }
	  ]]>
	</method>


	<method name="handle_UIDidGenerateNewCity" args="args"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadCity" args="args"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIDidLoadScenario" args="args"><![CDATA[
	    this.resetCity();
	  ]]>
	</method>


	<method name="handle_UIStartEarthquake" args="args"><![CDATA[
	    this.setAttribute("quaking", parseInt(args['magnitude']));
	  ]]>
	</method>


	<method name="handle_UIStopEarthquake" args="args"><![CDATA[
	    this.setAttribute("quaking", 0);
	  ]]>
	</method>


	<method name="handle_UIMakeSound" args="args"><![CDATA[
	    var channel = args['channel'];
	    var sound = args['sound'];
	    Debug.write("MAKE SOUND", "channel", channel, "sound", sound);
	  ]]>
	</method>


	<method name="handle_UINewGame" args="args"><![CDATA[
	    Debug.write("UINewGame");
	  ]]>
	</method>


	<method name="playWithThisCity"><![CDATA[
	    this.setAttribute("gameMode", "play");
	  ]]>
	</method>


	<method name="chooseCity"><![CDATA[
	    this.setAttribute("gameMode", "start");
	  ]]>
	</method>


        <node id="gSessionData"
            datapath="ds_session:/session"
        >


            <attribute name="sessionID" type="string" value="$path{'@sessionID'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_session ondata", this.sessionID);
                classroot.startSession(this.sessionID);
              ]]>
            </handler>


            <handler name="onerror" reference="ds_session"><![CDATA[
                Debug.write("ds_session onerror", this.sessionID);
                classroot.failSession();
              ]]>
            </handler>


            <handler name="ontimeout" reference="ds_session"><![CDATA[
                Debug.write("ds_session ontimeout", this.sessionID);
                classroot.failSession();
              ]]>
            </handler>


        </node>


        <node id="pollData"
            datapath="ds_poll:/poll"
        >


            <attribute name="ref" value="$path{'@ref'}"/>


            <handler name="ondata"><![CDATA[
                //Debug.write("ds_poll");

                var poll = ds_poll.data;
                var pollChildren = poll['childNodes'];
                if (pollChildren && (pollChildren.length > 0)) {
                    var i;
                    var n = pollChildren.length;
                    for (i = 0; i < n; i++) {
                        var pollChild = pollChildren[i];
                        if (pollChild.nodeType != 1) {
                            continue;
                        }

			//Debug.write(pollChild.nodeName, pollChild);

                        switch (pollChild.nodeName) {

                            case "tileviews": {

                                var tileviews = pollChild['childNodes'];
                                if (!tileviews) {
                                    break;
                                }

                                //Debug.write("tileviews", tileviews);
                                if (!tileviews || tileviews.length == 0) {
                                    break;
                                }

                                var j;
                                var m = tileviews.length;
                                for (j = 0; j < m; j++) {
                                    var tileview = tileviews[j];
                                    if (tileview.nodeType != 1) {
                                        continue;
                                    }

                                    var attributes = tileview.attributes;

                                    //Debug.write("tileview", attributes);

                                    var col = parseInt(attributes['col']);
                                    var row = parseInt(attributes['row']);
                                    var cols = parseInt(attributes['cols']);
                                    var rows = parseInt(attributes['rows']);
                                    var format = parseInt(attributes['format']);
                                    var children = tileview['childNodes'];
                                    var codedTiles = (children && (children.length > 0)) ? children[0].data : "";

                                    //Debug.write(col, row, cols, rows, format, codedTiles);

                                    if (!isNaN(col) &&
                                        !isNaN(row) &&
                                        !isNaN(cols) &&
                                        !isNaN(rows) &&
                                        !isNaN(format) &&
                                        (rows > 0) &&
                                        (cols > 0) &&
                                        (codedTiles != "")) {
                                        classroot.updateTiles(
                                            col,
                                            row,
                                            cols,
                                            rows,
                                            format,
                                            codedTiles);
                                    }
                                }

                                break;
                            }

                            case "messages": {

                                var messages = pollChild['childNodes'];
                                if (!messages || (messages.length == 0)) {
                                    break;
                                }

				var j;
				var m = messages.length;
				for (j = 0; j < m; j++) {
				    var messageEl = messages[j];
				    var attributes = messageEl.attributes;
				    var messageName = attributes['message'];
				    if (!messageName) {
					continue;
				    }
				    var methodName = "handle_" + messageName;
				    var method = classroot[methodName];
				    //Debug.write("method", methodName, method, "atts", attributes);
				    if (!method) {
					Debug.write("Undefined message:", messageName, messageEl, attributes);
					continue;
				    }
				    method.call(classroot, attributes);
				}

				break;
			    }

                        }

                    }
                }

                classroot.pollContinue(false);
              ]]>
            </handler>


            <handler name="onerror" reference="ds_poll"><![CDATA[
                Debug.write("ds_poll onerror", this.sessionID);
                classroot.failPoll();
              ]]>
            </handler>


            <handler name="ontimeout" reference="ds_poll"><![CDATA[
                Debug.write("ds_poll ontimeout", this.sessionID);
                classroot.failPoll();
              ]]>
            </handler>


        </node>

	<view name="connectScreen" id="gConnectScreen"
	    x="5"
	    y="5"
	    width="${parent.width - 10}"
	    height="${parent.height - 10}"
	    visible="${!classroot.connected}"
	>

	    <simplelayout 
	        axis="y" 
	        spacing="5"
	    />

	    <text
		visible="${classroot.connecting}"
		text="Connecting to server..."
		resize="true"
	    />

	    <text
		visible="${classroot.connectionFailed}"
		text="Connection to server failed."
		resize="true"
	    />

	    <button
		visible="${classroot.connectionFailed}"
		text="Reconnect"
		onclick="classroot.requestStartSession()"
	    />

	</view>

	<view name="startScreen" id="gStartScreen"
	    x="5"
	    y="5"
	    width="${parent.width - 10}"
	    height="${parent.height - 10}"
	    visible="${(classroot.gameMode == 'start') &amp;&amp; classroot.connected}"
	>

	    <simplelayout axis="x"
		spacing="5"
	    />

	    <view name="v1"
	        height="${parent.height}"
		width="${this.preview.width + 10}"
	    >

		<text name="title"
		    text="Micropolis: Choose a City"
		    fontsize="20"
		    fontstyle="bold"
		    resize="true"
		    x="${(parent.width - this.width) / 2}"
		    y="5"
		/>

		<view name="descriptionView"
		    y="${parent.title.y + parent.title.height + 5}"
		    width="${parent.preview.width}"
		    height="${parent.preview.y - this.y - 5}"
		>

		    <vscrollbar/>

		    <text name="description"
			fontsize="14"
			multiline="true"
			width="${parent.width - 15}"
		    >Welcome to Micropolis!<br/><br/>
Choose a city by selecting a scenario from the 'Scenarios' tab, or generating a new random city from the 'Generator' tab, or loading a city in the library from the 'Library' tab.<br/><br/>
Then press the 'Play with This City' button below, to start playing Micropolis!</text>

    	       </view>

		<previewmapview name="preview"
		    y="${parent.playButton.y - this.height - 5}"
		/>

	        <button name="playButton"
		    text="Play with This City"
		    onclick="classroot.playWithThisCity()"
		    y="${parent.height - this.height - 5}"
		    width="${parent.preview.width}"
	        />

	    </view>

	    <tabs
		width="${parent.width - this.x}"
		height="${parent.height}"
	    >

		<tabpane
		    text="Scenarios"
		    height="${parent.height}"
		>

		    <view
			width="${parent.width - 20}"
			height="${parent.height - 50}"
			clip="true"
		    >

			<simplelayout axis="y"
			    spacing="5"
			/>

			<button
			    datapath="ds_scenarios:/scenarios/scenario"
			    onclick="this.selectScenario()"
			    width="${parent.width}"
			>

			    <attribute name="scenarioID" value="$path{'@id'}" type="string"/>
			    <attribute name="scenarioName" value="$path{'@name'}" type="string"/>
			    <attribute name="scenarioYear" value="$path{'@year'}" type="string"/>
			    <attribute name="scenarioTagLine" value="$path{'@tagline'}" type="string"/>
			    <attribute name="scenarioDescription" value="$path{'description/text()'}" type="string"/>
			    <attribute name="scenarioCommand" value="$path{'command'}"/>

			    <handler name="ondata"><![CDATA[
				var label =
				    this.scenarioName + ', ' + this.scenarioYear + ': ' + 
				    this.scenarioTagLine;
				Debug.write("scenario button ondata", this, label);
				this.setAttribute("text", label);
			      ]]>
			    </handler>

			    <method name="selectScenario"><![CDATA[
			        classroot.sendCommand(this.scenarioCommand.serialize());
				classroot.setDescription(this.scenarioDescription);
			      ]]>
			    </method>

			</button>

		    </view>

		</tabpane>

		<tabpane
		    text="Generator"
		    width="${parent.width}"
		    height="${parent.height}"
		>

		    <view
			width="${parent.width - 20}"
			height="${parent.height - 50}"
			clip="true"
		    >

			<simplelayout axis="y"
			    spacing="5"
			/>

			<button
			    text="Generate Random City"
			    onclick="this.generateCity()"
			    width="${parent.width}"
			>

			    <method name="generateCity"><![CDATA[
			        classroot.sendCommand('<command name="generateCity"/>');
				classroot.setDescription("Generated a new random city.");
			      ]]>
			    </method>

			</button>

		    </view>

		</tabpane>

		<tabpane
		    text="Library"
		    width="${parent.width}"
		    height="${parent.height}"
		>

		    <view
			width="${parent.width - 20}"
			height="${parent.height - 50}"
			clip="true"
		    >

			<list
			    x="0"
			    y="0"
			    width="${parent.width}"
			    height="${parent.height}"
			>

			    <textlistitem
				datapath="ds_cities:/cities/city"
				onclick="this.loadCity()"
				text="$path{'@name'}"
				value="$path{'@id'}"
			    >

				<attribute name="loadCityCommand" value="$path{'command'}"/>

			        <method name="loadCity"><![CDATA[
				    classroot.sendCommand(this.loadCityCommand.serialize())
				    classroot.setDescription("Loaded city: " + this.text);
				  ]]>
				</method>

			    </textlistitem>

			</list>


		    </view>

		</tabpane>

	    </tabs>

	</view>

	<view name="playScreen" id="gPlayScreen"
	    x="0"
	    y="0"
	    width="${parent.width}"
	    height="${parent.height}"
	    visible="${(classroot.gameMode == 'play') &amp;&amp; classroot.connected}"
	>

	    <hresizebar name="hsep1" id="gHSep1"
		trackvar="'panelResizeBarY'"
		maxy="${parent.height - this.height}"
		defaulty="$once{classroot.panelResizeBarY}"
		x="0"
		y="$once{classroot.panelResizeBarY}"
		width="${parent.width}"
		height="${classroot.panelResizeBarSize}"
		overhang="0"
	    />

	    <tileview name="tileView" id="gTileView"
		x="0"
		y="${parent.hsep1.y + parent.hsep1.height}"
		width="${parent.width}"
		height="${parent.height - this.y}"
		bgcolor="0xBC6F56"
	    />


	    <view name="top"
		x="0"
		y="0"
		width="${parent.width}"
		height="${parent.hsep1.y}"
		clip="true"
	    >

		<vresizebar name="vsep1" id="gVSep1"
		    trackvar="'panelResizeBar2X'"
		    maxx="${parent.width - this.width}"
		    defaultx="$once{classroot.panelResizeBar2X}"
		    x="$once{classroot.panelResizeBar2X}"
		    y="0"
		    width="${classroot.panelResizeBarSize}"
		    height="${parent.height - this.y}"
		    overhang="0"
		/>

		<view name="topRight" id="gTopRight"
		    x="${parent.vsep1.x + parent.vsep1.width}"
		    y="0"
		    width="${parent.width - this.x}"
		    height="${parent.height}"
		    clip="true"
		>

		    <tabs
			width="${parent.width}"
			height="${parent.height}"
		    >

			<tabpane
			    text="Notice"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <noticeview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Messages"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <messageview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Evaluation"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <evaluationview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="History"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <graphview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Budget"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <budgetview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Overlays"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <overlaysview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Disasters"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <disastersview
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

			<tabpane
			    text="Control"
			    width="${parent.width}"
			    height="${parent.height}"
			>
			    <controlpanel
				width="${parent.width}"
				height="${parent.height}"
			    />
			</tabpane>

		    </tabs>

		</view>

		<view name="topLeft" id="gTopLeft"
		    bgcolor="0x808080"
		    x="0"
		    y="0"
		    width="${parent.vsep1.x}"
		    height="${parent.parent.height}"
		    clip="true"
		>

		    <view width="${parent.width}">

			<view name="demandGauge"
			    x="${classroot.gap}"
			    y="${classroot.gap}"
			    width="${classroot.demandWidth}"
			    height="${classroot.demandHeight}"
			    bgcolor="${0x404040}"
			/>

			<view name="dateFundsDisplay"
			    x="${parent.demandGauge.x + parent.demandGauge.width + classroot.gap}"
			    y="${classroot.gap}"
			    width="${(parent.width - classroot.gap) - this.x}"
			    height="${parent.demandGauge.height}"
			    bgcolor="${0xffffff}"
			    clip="true"
			>

			    <simplelayout 
				axis="y" 
			    />

			    <text
				text="Date:"
			    />

			    <text
				text="Apr 1966"
				resize="true"
			    />

			    <text
				text="Funds:"
				resize="true"
			    />

			    <text
				text="$472,332"
				resize="true"
			    />

			</view>

			<navigationmapview
			    x="${classroot.gap}"
			    y="${parent.dateFundsDisplay.y + parent.dateFundsDisplay.height + classroot.gap}"
			/>

		    </view>

		</view>

	    </view>

	</view>

    </class>


</library>
