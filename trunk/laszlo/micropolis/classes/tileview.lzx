<library>


    <!-- Tile View -->
    <!-- Written for Micropolis -->
    <!-- By Don Hopkins -->
    <!-- Licensed under GPLv3 -->


    <class name="tileview"
        clip="true"
    >


        <attribute name="active" value="true"/>
        <attribute name="uniqueID" value="null"/>
        <attribute name="zoom" value="2"/>
        <attribute name="tileSize" value="16"/>
        <attribute name="viewTileSize" value="${this.zoom * this.tileSize}"/>
        <attribute name="viewCol" value="0"/>
        <attribute name="viewRow" value="0"/>
        <attribute name="viewCols" value="0"/>
        <attribute name="viewRows" value="0"/>
        <attribute name="viewX" value="${-(this.container.x / this.viewTileSize)}"/>
        <attribute name="viewY" value="${-(this.container.y / this.viewTileSize)}"/>
        <attribute name="viewWidth" value="${this.width / this.viewTileSize}"/>
        <attribute name="viewHeight" value="${this.height / this.viewTileSize}"/>
        <attribute name="screenCol" value="${Math.floor(this.viewX)}"/>
        <attribute name="screenRow" value="${Math.floor(this.viewY)}"/>
        <attribute name="screenCols" value="${Math.floor(2 + this.viewWidth)}"/>
        <attribute name="screenRows" value="${Math.floor(2 + this.viewHeight)}"/>
        <attribute name="navigationMapView" value="null"/>


        <handler name="oninit"><![CDATA[
            //Debug.write("tileview init", this);

            this.uniqueID = gApp.makeUniqueID();

            this.updateInterests();
          ]]>
        </handler>


        <handler name="ondestroy"><![CDATA[
            gApp.removePoller(this);
            gApp.removeAnimator(this);
          ]]>
        </handler>


        <handler name="onactive"><![CDATA[
            //Debug.write("tileview onactive", this.active);
            this.updateInterests();
          ]]>
        </handler>


        <handler name="onvisible"><![CDATA[
            //Debug.write("tileview onvisible", this.visible);
            this.updateInterests();
          ]]>
        </handler>


        <handler name="onviewX"><![CDATA[
            this.handleUpdateViewRect();
          ]]>
        </handler>


        <handler name="onviewY"><![CDATA[
            this.handleUpdateViewRect();
          ]]>
        </handler>


        <handler name="onviewWidth"><![CDATA[
            this.handleUpdateViewRect();
          ]]>
        </handler>


        <handler name="onviewHeight"><![CDATA[
            this.handleUpdateViewRect();
          ]]>
        </handler>


        <handler name="onpaused" reference="gApp"><![CDATA[
            this.updateInterests();
          ]]>
        </handler>


	<method name="constrainPan"><![CDATA[
	  ]]>
	</method>


	<method name="scrollView" args="x, y"><![CDATA[
	    var container = this.container;
	    x = -(x * this.viewTileSize);
	    if (x != container.x) {
	        container.setAttribute("x", x);
	    }
	    y = -(y * this.viewTileSize);
	    if (y != container.y) {
	        container.setAttribute("y", y);
	    }
	    this.constrainPan();
	  ]]>
	</method>


        <method name="handleUpdateViewRect"><![CDATA[
	    var navigationMapView = this.navigationMapView;
	    if (navigationMapView) {
	        navigationMapView.updateViewLocation();
	    }
          ]]>
        </method>


        <method name="updateInterests"><![CDATA[
            if (this.active && this.visible) {
                gApp.addPoller(this);
                if (gApp.paused) {
                    //gApp.addAnimator(this);
                    gApp.removeAnimator(this);
                } else {
                    gApp.addAnimator(this);
                }
            } else {
                gApp.removePoller(this);
                gApp.removeAnimator(this);
            }
          ]]>
        </method>


        <method name="updateViewRect"><![CDATA[
            var v = (this.width > 0) && (this.height > 0);
            if (v != this.visible) {
                this.setAttribute("visible", v);
            }

            var col = this.screenCol;
            var row = this.screenRow;
            var cols = this.screenCols;
            var rows = this.screenRows;

            var left = Math.max(0, col);
            var top = Math.max(0, row);
            var right = Math.min(col + cols, gApp.worldCols);
            var bottom = Math.min(row + rows, gApp.worldRows);

            this.setAttribute("viewCol", left);
            this.setAttribute("viewRow", top);
            this.setAttribute("viewCols", Math.max(0, right - left));
            this.setAttribute("viewRows", Math.max(0, bottom - top));
          ]]>
        </method>


	<method name="getViewRect"><![CDATA[
	    return [
	        this.viewX, this.viewY, this.viewWidth, this.viewHeight
	    ];
	  ]]>
	</method>


        <method name="poll"><![CDATA[
            //Debug.write("poll", this, this.viewCols, this.viewRows);

            // TODO: extend tiles in the direction of motion, for scroll look-ahead.

            this.updateViewRect();

            var xml = (
                '<tileview id="' + this.uniqueID +
                '" col="' + this.viewCol +
                '" row="' + this.viewRow +
                '" cols="' + this.viewCols +
                '" rows="' + this.viewRows +
                '" viewX="' + this.viewX +
                '" viewY="' + this.viewY +
                '" viewWidth="' + this.viewWidth +
                '" viewHeight="' + this.viewHeight +
                '"/>');
            //Debug.write(xml);
            return xml;
          ]]>
        </method>


        <method name="doAnimate"><![CDATA[
            //Debug.write("doAnimate", this);
            var tileDictRows = gApp.tileDictRows;
            var viewCol = this.viewCol;
            var viewRow = this.viewRow;
            var viewCols = this.viewCols;
            var viewRows = this.viewRows;
            var viewTileSize = this.viewTileSize;
            var lastCol = viewCol + viewCols;
            var lastRow = viewRow + viewRows;
            var animationTicks = gApp.animationTicks;
            var maxNewTiles = 500;
            var newTiles = 0;

            var tileIndex = 0;

            var col, row;
            for (row = viewRow; row < lastRow; row++) {
                var tileDictRow = tileDictRows[row];
                for (col = viewCol; col < lastCol; col++) {
                    var tileDict = tileDictRow[col];
                    if (!tileDict) {
                        continue;
                    }

                    //Debug.write("this.container.subviews.length", this.container.subviews.length, "tileIndex", tileIndex);
                    if (tileIndex >= this.container.subviews.length) {
                        if (newTiles >= maxNewTiles) {
                            continue;
                        }
                        newTiles++;
                        var v =
                            new lz.tile(this.container);
                        //Debug.write("NOW this.container.subviews.length", this.container.subviews.length, "tileIndex", tileIndex);
                    }

                    var tile = this.container.subviews[tileIndex];
                    if (!tile) {
                        Debug.write("No tile!", this.container.subviews.length, tileIndex, this.container.subviews);
                        return;
                    }
                    tileIndex++;

                    var x = col * viewTileSize;
                    var y = row * viewTileSize;
                    //Debug.write("TILE", tile);
                    if (tile.x != x) {
                        tile.setAttribute("x", x);
                    }
                    if (tile.y != y) {
                        tile.setAttribute("y", y);
                    }

                    var frame = tileDict['index'];
                    if ((tileDict['animationTicks'] < animationTicks) &&
                        tileDict['animated']) {
                        tileDict['animationTicks'] = animationTicks;
                        var newFrame = gAniTiles[frame];
                        var animated = frame != newFrame;
                        if (animated) {
                            tileDict['index'] = frame = newFrame;
                        } else {
                            tileDict['animated'] = false;
                        }
                    }

                    if (tile.frame != (frame + 1)) {
                        tile.setAttribute("frame", frame + 1);
                    }

                   if (tile.visible != true) {
                       tile.setAttribute("visible", true);
                    }
                }
            }

            var subviews = this.container.subviews;
            var n = subviews.length;
            while (tileIndex < n) {
                var tile = subviews[tileIndex];
                if (tile.visible) {
                    tile.setAttribute("visible", false);
                }
                tileIndex++;
            }
          ]]>
        </method>


        <method name="centerOnTile" args="tileX, tileY"><![CDATA[
            //Debug.write("tileview centerOnTile", this, tileX, tileY);
            var viewTileSize = this.viewTileSize;
            var tileCenterX = (tileX * viewTileSize) + (viewTileSize / 2);
            var tileCenterY = (tileY * viewTileSize) + (viewTileSize / 2);
            var cornerX = Math.floor(tileCenterX - (this.width / 2));
            var cornerY = Math.floor(tileCenterY - (this.height / 2));
            //Debug.write("center", tileCenterX, tileCenterY, "corner", cornerX, cornerY);
            this.container.setAttribute("x", -cornerX);
            this.container.setAttribute("y", -cornerY);
          ]]>
        </method>


        <view name="container"
            width="${gApp.worldCols * classroot.viewTileSize}"
            height="${gApp.worldRows * classroot.viewTileSize}"
            bgcolor="0xCC7F66"
            onmousedown="this.dragger.setAttribute('applied', true)"
            onmouseup="this.dragger.setAttribute('applied', false)"
        >


            <dragstate name="dragger"/>


	    <handler name="onx"><![CDATA[
	        this.constrainPan();
	      ]]>
	    </handler>

	    <handler name="onx"><![CDATA[
	        this.constrainPan();
	      ]]>
	    </handler>


        </view>


    </class>


</library>
